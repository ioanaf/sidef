
=encoding utf8

=head1 NAME

Sidef::Types::Number::Number

=head1 DESCRIPTION

The C<Number> class implements support for numerical operations, supporting integers, rationals, floating-points and complex numbers at arbitrary precision.

This class also implements many useful mathematical methods, from basic arithmetical operations, to advanced number-theoretic functions, including primality testing and prime factorization methods.

=head1 SYNOPSIS

    var a = Num(string)
    var b = Number(string, base)

=head1 INHERITS

Inherits methods from:

       * Sidef::Object::Object

=head1 METHODS

=head2 !

    n!

Factorial of C<n>. (C<1*2*3*...*n>)

Aliases: I<fac>, I<factorial>

=cut

=head2 !!

    n!!

Double-factorial of C<n>.

Aliases: I<dfac>, I<dfactorial>, I<double_factorial>

=cut

=head2 %

    n % k

Remainder of C<n/k>.

Aliases: I<mod>

=cut

=head2 %%

    n %% k

Returns true if C<n> is divisible by C<k>. False otherwise.

Aliases: I<is_div>

=cut

=head2 &

    a & b

Bitwise AND operation.

Aliases: I<and>

=cut

=head2 *

    a * b

Multiplication of C<a> and C<b>.

Aliases: I<mul>

=cut

=head2 **

    a**b

Exponentiation: C<a> to power C<b>.

Aliases: I<pow>

=cut

=head2 +

    a + b

Addition of C<a> and C<b>.

Aliases: I<add>

=cut

=head2 ++

    n.inc

Increment C<n> by C<1> and return the result.

Aliases: I<inc>

=cut

=head2 -

    a - b

Subtraction of C<a> and C<b>.

Aliases: I<sub>

=cut

=head2 --

    n.dec

Decrement C<n> by C<1> and return the result.

Aliases: I<dec>

=cut

=head2 ..

    a .. b

Create an inclusive-inclusive C<RangeNum> object, from C<a> to C<b>.

Equivalent with:

    RangeNum(a, b)

Aliases: I<to>, I<upto>

=cut

=head2 ..^

    a ..^ b

Create an inclusive-exclusive C<RangeNum> object, from C<a> to C<b-1>.

Equivalent with:

    RangeNum(a, b-1)

Aliases: I<xto>, I<xupto>

=cut

=head2 /

    a / b

Division of C<a> by C<b>.

Aliases: I<÷>, I<div>

=cut

=head2 //

    a // b

Integer division of C<a> and C<b>.

Aliases: I<idiv>

=cut

=head2 :

    a : b

Create a new complex number.

Equivalent with:

    Complex(a, b)

Aliases: I<pair>

=cut

=head2 <

    a < b

Returns true if C<a> is less than C<b>.

Aliases: I<lt>

=cut

=head2 <<

    a << b

Bitwise left-shift, equivalent with (assuming C<a> and C<b> are integers):

    int(a * 2**b)

Aliases: I<lsft>, I<shift_left>

=cut

=head2 <=>

    a <=> b

Comparison of C<a> with C<b>. Returns C<-1> if C<a> is less than C<b>, C<0> if C<a> and C<b> are equal and C<+1> if C<a> is greater than C<b>.

Aliases: I<cmp>

=cut

=head2 approx_cmp

    approx_cmp(a, b)
    approx_cmp(a, b, k)

Approximate comparison of C<a> and C<b>.

Equivalent with:

    a.round(k) <=> b.round(k)

When C<k> is omitted, it uses the default floating-point precision to deduce C<k>.

=cut

=head2 ==

    a == b

Equality check. Returns true if C<a> and C<b> are equal.

Aliases: I<eq>

=cut

=head2 >

    a > b

Returns true if C<a> is greater than C<b>. False otherwise.

Aliases: I<gt>

=cut

=head2 >>

    a >> b

Bitwise right-shift, equivalent with (assuming C<a> and C<b> are integers):

    int(a / 2**b)

Aliases: I<rsft>, I<shift_right>

=cut

=head2 ^

    a ^ b

Bitwise XOR operation.

Aliases: I<xor>

=cut

=head2 ^..

    a ^.. b

Creates a reversed exclusive-inclusive C<RangeNum> object, from C<a-1> down to C<b>.

Equivalent with:

    RangeNum(a-1, b, -1)

Aliases: I<xdownto>

=cut

=head2 C

    Num.C
    Num.catalan_G

Returns the Catalan constant: 0.915965594177...

Aliases: I<catalan_G>

=cut

=head2 Y

Number.Y() -> I<Obj>

Return the

Aliases: I<γ>, I<euler_gamma>

=cut

=head2 |

I<Obj> B<|> I<Obj> -> I<Obj>

Return the

Aliases: I<or>

=cut

=head2 ~

I<Obj> B<~> I<Obj> -> I<Obj>

Return the

Aliases: I<not>

=cut

=head2 Γ

Number.Γ() -> I<Obj>

Return the

Aliases: I<gamma>

=cut

=head2 δ

Number.δ() -> I<Obj>

Return the

Aliases: I<kronecker_delta>

=cut

=head2 ζ

Number.ζ() -> I<Obj>

Return the

Aliases: I<zeta>

=cut

=head2 η

Number.η() -> I<Obj>

Return the

Aliases: I<eta>

=cut

=head2 μ

Number.μ() -> I<Obj>

Return the

Aliases: I<mu>, I<mobius>, I<möbius>, I<moebius>

=cut

=head2 Π

Number.Π() -> I<Obj>

Return the

Aliases: I<prod>

=cut

=head2 π

Number.π() -> I<Obj>

Return the

Aliases: I<pi>

=cut

=head2 Σ

Number.Σ() -> I<Obj>

Return the

Aliases: I<sum>

=cut

=head2 σ

Number.σ() -> I<Obj>

Return the

Aliases: I<sigma>

=cut

=head2 τ

Number.τ() -> I<Obj>

Return the

Aliases: I<tau>

=cut

=head2 φ

Number.φ() -> I<Obj>

Return the

Aliases: I<phi>

=cut

=head2 Ψ

Number.Ψ() -> I<Obj>

Return the

Aliases: I<digamma>

=cut

=head2 Ω

Number.Ω() -> I<Obj>

Return the

Aliases: I<bigomega>, I<prime_power_sigma0>

=cut

=head2 ω

Number.ω() -> I<Obj>

Return the

Aliases: I<omega>, I<prime_sigma0>, I<prime_power_usigma0>

=cut

=head2 ≅

I<Obj> B<≅> I<Obj> -> I<Obj>

Return the

Aliases: I<=~=>, I<approx_eq>

=cut

=head2 ≠

I<Obj> B<≠> I<Obj> -> I<Obj>

Return the

Aliases: I<!=>, I<ne>

=cut

=head2 ≤

I<Obj> B<≤> I<Obj> -> I<Obj>

Return the

Aliases: I<E<lt>=>, I<le>

=cut

=head2 ≥

I<Obj> B<≥> I<Obj> -> I<Obj>

Return the

Aliases: I<E<gt>=>, I<ge>

=cut

=head2 abs

    n.abs

Absolute value of C<n>.

=cut

=head2 abundancy

Number.abundancy() -> I<Obj>

Return the

Aliases: I<abundancy_index>

=cut

=head2 acmp

Number.acmp() -> I<Obj>

Return the

=cut

=head2 acos

    n.acos

Inverse cosine of C<n> in radians.

=cut

=head2 acosh

    n.acosh

Inverse hyperbolic cosine of C<n>.

=cut

=head2 acot

    n.acot

Inverse cotangent of C<n> in radians.

=cut

=head2 acoth

    n.acoth

Inverse hyperbolic cotangent of C<n>.

=cut

=head2 acsc

    n.acsc

Inverse cosecant of C<n> in radians.

=cut

=head2 acsch

    n.acsch

Inverse hyperbolic cosecant of C<n>.

=cut

=head2 addmod

Number.addmod() -> I<Obj>

Return the

=cut

=head2 agm

    agm(a, b)

Arithmetic-geometric mean of C<a> and C<b>.

=cut

=head2 ai

    x.ai
    Ai(x)

Airy function of the first kind: C<Ai(x)>.

Aliases: I<airy>

=cut

=head2 all_composite

Number.all_composite() -> I<Obj>

Return the

=cut

=head2 all_prime

Number.all_prime() -> I<Obj>

Return the

=cut

=head2 approx_ge

    approx_ge(a, b)
    approx_ge(a, b, k)

True if C<a> is approximately greater than or equal to C<b>.

Equivalent with:

    a.round(k) >= b.round(k)

=cut

=head2 approx_gt

    approx_gt(a, b)
    approx_gt(a, b, k)

True if C<a> is approximately greater than C<b>.

Equivalent with:

    a.round(k) > b.round(k)

=cut

=head2 approx_le

    approx_le(a, b)
    approx_le(a, b, k)

True if C<a> is approximately less than or equal to C<b>.

Equivalent with:

    a.round(k) <= b.round(k)

=cut

=head2 approx_lt

    approx_lt(a, b)
    approx_lt(a, b, k)

True if C<a> is approximately less than C<b>.

Equivalent with:

    a.round(k) < b.round(k)

=cut

=head2 approx_ne

    approx_ne(a, b)
    approx_ne(a, b, k)

True if C<a> is approximately different than C<b>.

Equivalent with:

    a.round(k) != b.round(k)

=cut

=head2 as_bin

    n.as_bin

Returns a C<String> with the binary representation of C<n>.

Example:

    say 42.as_bin     # "101011"

=cut

=head2 as_dec

    n.as_dec
    n.as_dec(k)

Given a rational number C<n>, it returns its decimal expansion as a C<String> object, expanded at C<k> decimal places.

Example:

    say (1/17 -> as_dec(10))      # 0.05882352941
    say (1/17 -> as_dec(30))      # 0.0588235294117647058823529411765

Aliases: I<as_float>

=cut

=head2 asec

    n.asec

Inverse secant of C<n> in radians.

=cut

=head2 asech

    n.asech

Inverse hyperbolic secant of C<n>.

=cut

=head2 as_frac

    n.as_frac
    n.as_frac(base)

String-representation of C<n> as fraction.

Example:

    say 24.as_frac                 # 24/1
    say bernoulli(10).as_frac      # 5/66
    say bernoulli(12).as_frac(36)  # -j7/23u

If C<n> is an integer, it uses C<1> for the denominator.

=cut

=head2 as_hex

    n.as_hex

Returns a String representing the integer part of C<n> in hexadecimal (base 16).

Example:

    say 42.as_hex       # "2a"

Returns C<nil> when C<n> cannot be converted to an integer.

=cut

=head2 asin

    n.asin

Inverse sine of C<n> in radians.

=cut

=head2 asinh

    n.asinh

Inverse hyperbolic sine of C<n>.

=cut

=head2 as_int

    n.as_int
    n.as_int(base)

Returns a String representing the integer part of C<n> in a given base, where the base must be between 2 and 62.

When the base is omitted, it defaults to base 10.

Example:

    say 255.as_int      # "255"
    say 255.as_int(16)  # "ff"

Returns C<nil> when C<n> cannot be converted to an integer.

=cut

=head2 as_oct

    n.as_oct

Returns a String representing the integer part of C<n> in octal (base 8).

Example:

    say 42.as_oct   # 52

Returns C<nil> when C<n> cannot be converted to an integer.

=cut

=head2 as_rat

    n.as_rat
    n.as_rat(base)

Returns a rational string-representation of C<n> in a given base, where the base must be between 2 and 62.

When the base is omitted, it defaults to base 10.

Example:

    say as_rat(42)          # "42"
    say as_rat(2/4)         # "1/2"
    say as_rat(255, 16)     # "ff"

Returns C<nil> when C<n> cannot be converted to a rational number.

=cut

=head2 atan

    n.atan

Inverse tangent of C<n> in radians.

=cut

=head2 atan2

    atan2(a, b)

Four-quadrant inverse tangent of C<a> and C<b>.

=cut

=head2 atanh

    n.atanh

Inverse hyperbolic tangent of C<n>.

=cut

=head2 base

    n.base(b)

Returns a String-representation of C<n> in a given base C<b>, which must be between 2 and 62.

Aliases: I<in_base>

=cut

=head2 bell

    n.bell

Returns the n-th Bell number.

Aliases: I<bell_number>

=cut

=head2 bern

    n.bern
    bernoulli(n)
    bernoulli(n, x)

Returns the n-th Bernoulli number. When an additional argument is provided, it returns the n-th Bernoulli polynomial.

Example:

    say bernoulli(10).as_rat       # B_10    = 5/66
    say bernoulli(10, 2).as_rat    # B_10(2) = 665/66

Aliases: I<bernfrac>, I<bernoulli>, I<bernoulli_number>

=cut

=head2 bernoulli_polynomial

    bernoulli_polynomial(n, x)

Returns the n-th Bernoulli polynomial: C<B_n(x)>.

=cut

=head2 bernreal

    n.bernreal

Return an approximation to the n-th Bernoulli number as a floating-point number.

=cut

=head2 bessel_j

    bessel_j(x, n)

First order Bessel function: C<J_n(x)>.

=cut

=head2 bessel_y

    bessel_y(x, n)

Second order Bessel function: C<Y_n(x)>.

=cut

=head2 beta

    beta(a, b)

The beta function (also called the Euler integral of the first kind).

Defined as:

    beta(a, b) = gamma(a)*gamma(b) / gamma(a+b)

=cut

=head2 bit

    n.bit(k)
    n.getbit(k)

Returns 1 if bit C<k> of C<n> is set, and 0 if it is not set.

Return C<nil> when C<n> cannot be truncated to an integer or when C<k> is negative.

Example:

    say getbit(0b1001, 0)   # 1
    say getbit(0b1000, 0)   # 0

Aliases: I<getbit>, I<testbit>

=cut

=head2 bits

Number.bits() -> I<Obj>

Return the

=cut

=head2 bit_scan0

    n.bit_scan0
    n.bit_scan0(k)

Scan C<n>, starting from bit index C<k>, towards more significant bits, until a 0-bit is found.

When C<k> is omitted, C<k=0> is assumed.

Returns C<nil> if C<n> cannot be truncated to an integer or if C<k> is negative.

=cut

=head2 bit_scan1

    n.bit_scan1
    n.bit_scan1(k)

Scan C<n>, starting from bit index C<k>, towards more significant bits, until a 1-bit is found.

When C<k> is omitted, C<k=0> is assumed.

Returns C<nil> if C<n> cannot be truncated to an integer or if C<k> is negative.

=cut

=head2 bsearch

    bsearch(n, {...})
    bsearch(a, b, {...})

Binary search from to C<0> to C<n>, or from C<a> to C<b>, which can be any arbitrary large integers.

The last argument is a block which does the comparisons.

This function finds a value C<k> such that f(k) = 0. Returns C<nil> otherwise.

    say bsearch(20,      {|k| k*k  <=> 49   })   #=> 7   (7*7  = 49)
    say bsearch(3, 1000, {|k| k**k <=> 3125 })   #=> 5   (5**5 = 3125)

=cut

=head2 bsearch_ge

    bsearch_ge(n, {...})
    bsearch_ge(a, b, {...})

Binary search from to C<0> to C<n>, or from C<a> to C<b>, which can be any arbitrary large integers.

The last argument is a block which does the comparisons.

This function finds a value C<k> such that f(k-1) < 0 and f(k) >= 0. Returns C<nil> otherwise.

    bsearch_ge(1e6,       { .exp <=> 1e+9 })  #  21   (exp( 21) >= 1e+9)
    bsearch_ge(-1e6, 1e6, { .exp <=> 1e-9 })  # -20   (exp(-20) >= 1e-9)

=cut

=head2 bsearch_le

    bsearch_le(n, {...})
    bsearch_le(a, b, {...})

Binary search from to C<0> to C<n>, or from C<a> to C<b>, which can be any arbitrary large integers.

The last argument is a block which does the comparisons.

This function finds a value C<k> such that f(k) <= 0 and f(k+1) > 0. Returns C<nil> otherwise.

    bsearch_le(1e6,       { .exp <=> 1e+9 })  #  20   (exp( 20) <= 1e+9)
    bsearch_le(-1e6, 1e6, { .exp <=> 1e-9 })  # -21   (exp(-21) <= 1e-9)

=cut

=head2 bsearch_max

Number.bsearch_max() -> I<Obj>

Return the

=cut

=head2 bsearch_min

Number.bsearch_min() -> I<Obj>

Return the

=cut

=head2 bsearch_solve

Number.bsearch_solve() -> I<Obj>

Return the

Aliases: I<bsearch_inverse>

=cut

=head2 by

Number.by() -> I<Obj>

Return the

Aliases: I<first>

=cut

=head2 cadd

Number.cadd() -> I<Obj>

Return the

Aliases: I<complex_add>

=cut

=head2 catalan

    n.catalan
    n.catalan(k)

Returns the n-th Catalan number.

If two arguments are provided, it returns the C<C(n,k)> entry in Catalan's triangle.

=cut

=head2 cbrt

    n.cbrt

Cube root of C<n>.

=cut

=head2 cdiv

Number.cdiv() -> I<Obj>

Return the

Aliases: I<complex_div>

=cut

=head2 ceil

    n.ceil

Round C<n> towards positive Infinity.

Aliases: I<ceiling>

=cut

=head2 cfrac

    n.cfrac
    n.cfrac(k)

Compute C<k> terms of the simple continued-fraction expansion of C<n>.

Example:

    say sqrt(12).cfrac(6)    # [3, 2, 6, 2, 6, 2, 6]

Can also be used to compute very good rational approximations to a given real number:

    say Num.pi.cfrac(10).flip.reduce{|a,b| b + 1/a }.as_rat      # 4272943/1360120

When C<k> is omitted, it uses the default floating-point precision to deduce C<k>.

Aliases: I<as_cfrac>

=cut

=head2 chebyshev_T

    chebyshevT(n, x)

Compute the Chebyshev polynomials of the first kind: C<T_n(x)>, where C<n> must be a native integer.

Defined as:

    T(0, x) = 1
    T(1, x) = x
    T(n, x) = 2*x*T(n-1, x) - T(n-2, x)

Aliases: I<chebyshevt>, I<chebyshevT>

=cut

=head2 chebyshev_U

    chebyshevU(n, x)

Compute the Chebyshev polynomials of the second kind: C<U_n(x)>, where C<n> must be a native integer.

Defined as:

    U(0, x) = 1
    U(1, x) = 2*x
    U(n, x) = 2*x*U(n-1, x) - U(n-2, x)

Aliases: I<chebyshevu>, I<chebyshevU>

=cut

=head2 chr

    n.chr

Convert the integer C<n> into a character.

Example:

    say 97.chr      # "a"
    say 9786.chr    # "☺"

=cut

=head2 cinv

Number.cinv() -> I<Obj>

Return the

Aliases: I<complex_inv>

=cut

=head2 cinvmod

Number.cinvmod() -> I<Obj>

Return the

Aliases: I<complex_invmod>

=cut

=head2 circular_permutations

Number.circular_permutations() -> I<Obj>

Return the

=cut

=head2 cis

Number.cis() -> I<Obj>

Return the

=cut

=head2 clearbit

Number.clearbit() -> I<Obj>

Return the

=cut

=head2 cmod

Number.cmod() -> I<Obj>

Return the

Aliases: I<complex_mod>

=cut

=head2 cmul

Number.cmul() -> I<Obj>

Return the

Aliases: I<complex_mul>

=cut

=head2 combinations

Number.combinations() -> I<Obj>

Return the

=cut

=head2 combinations_with_repetition

Number.combinations_with_repetition() -> I<Obj>

Return the

=cut

=head2 commify

Number.commify() -> I<Obj>

Return the

=cut

=head2 complex

Number.complex() -> I<Obj>

Return the

=cut

=head2 complex_cmp

Number.complex_cmp() -> I<Obj>

Return the

=cut

=head2 complex_ipow

Number.complex_ipow() -> I<Obj>

Return the

=cut

=head2 composite

Number.composite() -> I<Obj>

Return the

Aliases: I<nth_composite>

=cut

=head2 composite_count

Number.composite_count() -> I<Obj>

Return the

=cut

=head2 conj

Number.conj() -> I<Obj>

Return the

Aliases: I<conjug>, I<conjugate>

=cut

=head2 consecutive_lcm

Number.consecutive_lcm() -> I<Obj>

Return the

Aliases: I<consecutive_integer_lcm>

=cut

=head2 convergents

Number.convergents() -> I<Obj>

Return the

=cut

=head2 core

Number.core() -> I<Obj>

Return the

=cut

=head2 cos

Number.cos() -> I<Obj>

Return the

=cut

=head2 cosh

Number.cosh() -> I<Obj>

Return the

=cut

=head2 cot

Number.cot() -> I<Obj>

Return the

=cut

=head2 coth

Number.coth() -> I<Obj>

Return the

=cut

=head2 cpow

Number.cpow() -> I<Obj>

Return the

Aliases: I<complex_pow>

=cut

=head2 cpowmod

Number.cpowmod() -> I<Obj>

Return the

Aliases: I<complex_powmod>

=cut

=head2 csc

Number.csc() -> I<Obj>

Return the

=cut

=head2 csch

Number.csch() -> I<Obj>

Return the

=cut

=head2 csub

Number.csub() -> I<Obj>

Return the

Aliases: I<complex_sub>

=cut

=head2 cyclotomic

Number.cyclotomic() -> I<Obj>

Return the

Aliases: I<cyclotomic_polynomial>

=cut

=head2 dconv

Number.dconv() -> I<Obj>

Return the

Aliases: I<dirichlet_convolution>

=cut

=head2 de

Number.de() -> I<Obj>

Return the

Aliases: I<denominator>

=cut

=head2 defs

Number.defs() -> I<Obj>

Return the

=cut

=head2 deg2rad

Number.deg2rad() -> I<Obj>

Return the

=cut

=head2 derangements

Number.derangements() -> I<Obj>

Return the

Aliases: I<complete_permutations>

=cut

=head2 derivative

Number.derivative() -> I<Obj>

Return the

Aliases: I<arithmetic_derivative>

=cut

=head2 digit

Number.digit() -> I<Obj>

Return the

=cut

=head2 digits

Number.digits() -> I<Obj>

Return the

=cut

=head2 digits2num

Number.digits2num() -> I<Obj>

Return the

Aliases: I<from_digits>

=cut

=head2 digits_sum

Number.digits_sum() -> I<Obj>

Return the

Aliases: I<sum_digits>, I<sumdigits>

=cut

=head2 dirichlet_sum

Number.dirichlet_sum() -> I<Obj>

Return the

Aliases: I<dirichlet_hyperbola>

=cut

=head2 divides

Number.divides() -> I<Obj>

Return the

=cut

=head2 divisor_map

Number.divisor_map() -> I<Obj>

Return the

=cut

=head2 divisor_prod

Number.divisor_prod() -> I<Obj>

Return the

Aliases: I<divisors_prod>

=cut

=head2 divisors

Number.divisors() -> I<Obj>

Return the

=cut

=head2 divisor_sum

Number.divisor_sum() -> I<Obj>

Return the

Aliases: I<divisors_sum>

=cut

=head2 divmod

Number.divmod() -> I<Obj>

Return the

=cut

=head2 downto

Number.downto() -> I<Obj>

Return the

=cut

=head2 dump

Number.dump() -> I<Obj>

Return the

=cut

=head2 e

Number.e() -> I<Obj>

Return the

=cut

=head2 each_prime

Number.each_prime() -> I<Obj>

Return the

Aliases: I<primes_each>

=cut

=head2 each_squarefree

Number.each_squarefree() -> I<Obj>

Return the

Aliases: I<squarefree_each>

=cut

=head2 ecm_factor

Number.ecm_factor() -> I<Obj>

Return the

=cut

=head2 ei

Number.ei() -> I<Obj>

Return the

Aliases: I<eint>

=cut

=head2 erf

Number.erf() -> I<Obj>

Return the

=cut

=head2 erfc

Number.erfc() -> I<Obj>

Return the

=cut

=head2 euler

Number.euler() -> I<Obj>

Return the

Aliases: I<euler_number>

=cut

=head2 euler_polynomial

Number.euler_polynomial() -> I<Obj>

Return the

=cut

=head2 exp

Number.exp() -> I<Obj>

Return the

=cut

=head2 exp10

Number.exp10() -> I<Obj>

Return the

=cut

=head2 exp2

Number.exp2() -> I<Obj>

Return the

=cut

=head2 exp_mangoldt

Number.exp_mangoldt() -> I<Obj>

Return the

=cut

=head2 expmod

Number.expmod() -> I<Obj>

Return the

Aliases: I<powmod>

=cut

=head2 factor

Number.factor() -> I<Obj>

Return the

Aliases: I<factors>

=cut

=head2 factor_exp

Number.factor_exp() -> I<Obj>

Return the

Aliases: I<factors_exp>

=cut

=head2 factorialmod

Number.factorialmod() -> I<Obj>

Return the

=cut

=head2 factorial_power

Number.factorial_power() -> I<Obj>

Return the

Aliases: I<factorial_valuation>

=cut

=head2 factorial_sum

Number.factorial_sum() -> I<Obj>

Return the

Aliases: I<left_factorial>

=cut

=head2 factor_map

Number.factor_map() -> I<Obj>

Return the

=cut

=head2 factor_prod

Number.factor_prod() -> I<Obj>

Return the

Aliases: I<factors_prod>

=cut

=head2 factor_sum

Number.factor_sum() -> I<Obj>

Return the

Aliases: I<factors_sum>

=cut

=head2 falling_factorial

Number.falling_factorial() -> I<Obj>

Return the

=cut

=head2 faulhaber

Number.faulhaber() -> I<Obj>

Return the

Aliases: I<faulhaber_sum>

=cut

=head2 faulhaber_polynomial

Number.faulhaber_polynomial() -> I<Obj>

Return the

=cut

=head2 fermat_factor

Number.fermat_factor() -> I<Obj>

Return the

=cut

=head2 fib

Number.fib() -> I<Obj>

Return the

Aliases: I<fibonacci>

=cut

=head2 fibmod

Number.fibmod() -> I<Obj>

Return the

Aliases: I<fibonacci_mod>, I<fibonaccimod>

=cut

=head2 flip

Number.flip() -> I<Obj>

Return the

Aliases: I<reverse>

=cut

=head2 flipbit

Number.flipbit() -> I<Obj>

Return the

=cut

=head2 floor

Number.floor() -> I<Obj>

Return the

=cut

=head2 gcd

Number.gcd() -> I<Obj>

Return the

=cut

=head2 gcdext

Number.gcdext() -> I<Obj>

Return the

=cut

=head2 geometric_sum

Number.geometric_sum() -> I<Obj>

Return the

=cut

=head2 gpf

Number.gpf() -> I<Obj>

Return the

=cut

=head2 hamdist

Number.hamdist() -> I<Obj>

Return the

=cut

=head2 harm

Number.harm() -> I<Obj>

Return the

Aliases: I<harmfrac>, I<harmonic>, I<harmonic_number>

=cut

=head2 harmreal

Number.harmreal() -> I<Obj>

Return the

=cut

=head2 hermite_H

Number.hermite_H() -> I<Obj>

Return the

Aliases: I<hermiteH>, I<hermite_polynomial_H>, I<hermite_polynomialH>

=cut

=head2 hermite_He

Number.hermite_He() -> I<Obj>

Return the

Aliases: I<hermiteHe>, I<hermite_polynomial_He>, I<hermite_polynomialHe>

=cut

=head2 holf_factor

Number.holf_factor() -> I<Obj>

Return the

=cut

=head2 hyperfactorial

Number.hyperfactorial() -> I<Obj>

Return the

=cut

=head2 hyperfactorial_ln

Number.hyperfactorial_ln() -> I<Obj>

Return the

Aliases: I<lnhyperfactorial>, I<hyperfactorial_log>

=cut

=head2 hypot

Number.hypot() -> I<Obj>

Return the

=cut

=head2 i

Number.i() -> I<Obj>

Return the

=cut

=head2 iadd

Number.iadd() -> I<Obj>

Return the

=cut

=head2 icbrt

Number.icbrt() -> I<Obj>

Return the

=cut

=head2 ilog

Number.ilog() -> I<Obj>

Return the

=cut

=head2 ilog10

Number.ilog10() -> I<Obj>

Return the

=cut

=head2 ilog2

Number.ilog2() -> I<Obj>

Return the

=cut

=head2 im

Number.im() -> I<Obj>

Return the

Aliases: I<imag>, I<imaginary>

=cut

=head2 imod

Number.imod() -> I<Obj>

Return the

=cut

=head2 imul

Number.imul() -> I<Obj>

Return the

=cut

=head2 inf

Number.inf() -> I<Obj>

Return the

=cut

=head2 int

Number.int() -> I<Obj>

Return the

Aliases: I<to_i>, I<to_int>, I<trunc>

=cut

=head2 inv

Number.inv() -> I<Obj>

Return the

=cut

=head2 inverse_phi

Number.inverse_phi() -> I<Obj>

Return the

Aliases: I<inverse_totient>, I<inverse_euler_phi>

=cut

=head2 inverse_polygonal

Number.inverse_polygonal() -> I<Obj>

Return the

Aliases: I<polygonal_inverse>

=cut

=head2 inverse_sigma

Number.inverse_sigma() -> I<Obj>

Return the

=cut

=head2 inverse_totient_len

Number.inverse_totient_len() -> I<Obj>

Return the

=cut

=head2 invmod

Number.invmod() -> I<Obj>

Return the

=cut

=head2 ipolygonal_root

Number.ipolygonal_root() -> I<Obj>

Return the

=cut

=head2 ipolygonal_root2

Number.ipolygonal_root2() -> I<Obj>

Return the

=cut

=head2 ipow

Number.ipow() -> I<Obj>

Return the

=cut

=head2 ipow10

Number.ipow10() -> I<Obj>

Return the

=cut

=head2 ipow2

Number.ipow2() -> I<Obj>

Return the

=cut

=head2 iquadratic_formula

Number.iquadratic_formula() -> I<Obj>

Return the

Aliases: I<integer_quadratic_formula>

=cut

=head2 irand

Number.irand() -> I<Obj>

Return the

=cut

=head2 iroot

Number.iroot() -> I<Obj>

Return the

=cut

=head2 irootrem

Number.irootrem() -> I<Obj>

Return the

=cut

=head2 is_abundant

Number.is_abundant() -> I<Obj>

Return the

=cut

=head2 is_aks_prime

Number.is_aks_prime() -> I<Obj>

Return the

=cut

=head2 is_almost_prime

Number.is_almost_prime() -> I<Obj>

Return the

=cut

=head2 is_between

Number.is_between() -> I<Obj>

Return the

=cut

=head2 is_bpsw_prime

Number.is_bpsw_prime() -> I<Obj>

Return the

=cut

=head2 is_carmichael

Number.is_carmichael() -> I<Obj>

Return the

=cut

=head2 is_chebyshev

Number.is_chebyshev() -> I<Obj>

Return the

Aliases: I<is_chebyshev_psp>, I<is_chebyshev_pseudoprime>

=cut

=head2 is_complex

Number.is_complex() -> I<Obj>

Return the

=cut

=head2 is_composite

Number.is_composite() -> I<Obj>

Return the

=cut

=head2 is_congruent

Number.is_congruent() -> I<Obj>

Return the

=cut

=head2 is_coprime

Number.is_coprime() -> I<Obj>

Return the

=cut

=head2 is_cube

Number.is_cube() -> I<Obj>

Return the

=cut

=head2 is_cyclic

Number.is_cyclic() -> I<Obj>

Return the

=cut

=head2 is_ecpp_prime

Number.is_ecpp_prime() -> I<Obj>

Return the

=cut

=head2 iseed

Number.iseed() -> I<Obj>

Return the

=cut

=head2 is_euler_psp

Number.is_euler_psp() -> I<Obj>

Return the

Aliases: I<is_euler_pseudoprime>

=cut

=head2 is_even

Number.is_even() -> I<Obj>

Return the

=cut

=head2 is_fib_psp

Number.is_fib_psp() -> I<Obj>

Return the

Aliases: I<is_lucasu_psp>, I<is_lucasU_psp>, I<is_fibonacci_psp>, I<is_lucasU_pseudoprime>, I<is_fibonacci_pseudoprime>

=cut

=head2 is_frobenius_psp

Number.is_frobenius_psp() -> I<Obj>

Return the

Aliases: I<is_frobenius_pseudoprime>

=cut

=head2 is_fundamental

Number.is_fundamental() -> I<Obj>

Return the

=cut

=head2 is_gaussian_prime

Number.is_gaussian_prime() -> I<Obj>

Return the

=cut

=head2 is_imag

Number.is_imag() -> I<Obj>

Return the

=cut

=head2 is_imprimitive_carmichael

Number.is_imprimitive_carmichael() -> I<Obj>

Return the

=cut

=head2 is_inf

Number.is_inf() -> I<Obj>

Return the

=cut

=head2 is_int

Number.is_int() -> I<Obj>

Return the

=cut

=head2 is_khashin_psp

Number.is_khashin_psp() -> I<Obj>

Return the

Aliases: I<is_khashin_pseudoprime>, I<is_frobenius_khashin_psp>, I<is_frobenius_khashin_pseudoprime>

=cut

=head2 is_lucas_carmichael

Number.is_lucas_carmichael() -> I<Obj>

Return the

=cut

=head2 is_lucas_psp

Number.is_lucas_psp() -> I<Obj>

Return the

Aliases: I<is_lucas_pseudoprime>

=cut

=head2 is_lucasv_psp

Number.is_lucasv_psp() -> I<Obj>

Return the

Aliases: I<is_lucasV_psp>, I<is_bruckman_lucas_psp>, I<is_lucasV_pseudoprime>, I<is_bruckman_lucas_pseudoprime>

=cut

=head2 is_mersenne_prime

Number.is_mersenne_prime() -> I<Obj>

Return the

=cut

=head2 is_mone

Number.is_mone() -> I<Obj>

Return the

=cut

=head2 is_nan

Number.is_nan() -> I<Obj>

Return the

=cut

=head2 is_neg

Number.is_neg() -> I<Obj>

Return the

Aliases: I<is_negative>

=cut

=head2 is_ninf

Number.is_ninf() -> I<Obj>

Return the

=cut

=head2 is_nm1_prime

Number.is_nm1_prime() -> I<Obj>

Return the

Aliases: I<is_nminus1_prime>

=cut

=head2 is_np1_prime

Number.is_np1_prime() -> I<Obj>

Return the

Aliases: I<is_nplus1_prime>

=cut

=head2 is_odd

Number.is_odd() -> I<Obj>

Return the

=cut

=head2 is_odd_composite

Number.is_odd_composite() -> I<Obj>

Return the

=cut

=head2 is_one

Number.is_one() -> I<Obj>

Return the

=cut

=head2 is_over_psp

Number.is_over_psp() -> I<Obj>

Return the

Aliases: I<is_over_pseudoprime>, I<is_overpseudoprime>

=cut

=head2 is_palindrome

Number.is_palindrome() -> I<Obj>

Return the

Aliases: I<is_palindromic>

=cut

=head2 is_pell_lucas_psp

Number.is_pell_lucas_psp() -> I<Obj>

Return the

Aliases: I<is_pell_lucas_pseudoprime>

=cut

=head2 is_pell_psp

Number.is_pell_psp() -> I<Obj>

Return the

Aliases: I<is_pell_pseudoprime>

=cut

=head2 is_perrin_psp

Number.is_perrin_psp() -> I<Obj>

Return the

Aliases: I<is_perrin_pseudoprime>

=cut

=head2 is_plumb_psp

Number.is_plumb_psp() -> I<Obj>

Return the

Aliases: I<is_euler_plumb_psp>, I<is_plumb_pseudoprime>, I<is_euler_plumb_pseudoprime>

=cut

=head2 is_polygonal

Number.is_polygonal() -> I<Obj>

Return the

=cut

=head2 is_polygonal2

Number.is_polygonal2() -> I<Obj>

Return the

=cut

=head2 is_pos

Number.is_pos() -> I<Obj>

Return the

Aliases: I<is_positive>

=cut

=head2 is_pow

Number.is_pow() -> I<Obj>

Return the

Aliases: I<is_power>, I<is_perfect_power>

=cut

=head2 is_powerful

Number.is_powerful() -> I<Obj>

Return the

=cut

=head2 is_power_of

Number.is_power_of() -> I<Obj>

Return the

=cut

=head2 is_practical

Number.is_practical() -> I<Obj>

Return the

=cut

=head2 is_prime

Number.is_prime() -> I<Obj>

Return the

=cut

=head2 is_prime_power

Number.is_prime_power() -> I<Obj>

Return the

=cut

=head2 is_primitive_root

Number.is_primitive_root() -> I<Obj>

Return the

=cut

=head2 is_prob_prime

Number.is_prob_prime() -> I<Obj>

Return the

=cut

=head2 is_prob_squarefree

Number.is_prob_squarefree() -> I<Obj>

Return the

=cut

=head2 is_prov_prime

Number.is_prov_prime() -> I<Obj>

Return the

Aliases: I<is_provable_prime>

=cut

=head2 is_psp

Number.is_psp() -> I<Obj>

Return the

Aliases: I<is_fermat_psp>, I<is_pseudoprime>, I<is_fermat_pseudoprime>

=cut

=head2 isqrt

Number.isqrt() -> I<Obj>

Return the

=cut

=head2 isqrtrem

Number.isqrtrem() -> I<Obj>

Return the

=cut

=head2 is_rat

Number.is_rat() -> I<Obj>

Return the

=cut

=head2 is_real

Number.is_real() -> I<Obj>

Return the

=cut

=head2 is_rough

Number.is_rough() -> I<Obj>

Return the

=cut

=head2 is_safe_prime

Number.is_safe_prime() -> I<Obj>

Return the

=cut

=head2 is_semiprime

Number.is_semiprime() -> I<Obj>

Return the

=cut

=head2 is_smooth

Number.is_smooth() -> I<Obj>

Return the

=cut

=head2 is_smooth_over_prod

Number.is_smooth_over_prod() -> I<Obj>

Return the

=cut

=head2 is_sqr

Number.is_sqr() -> I<Obj>

Return the

Aliases: I<is_square>, I<is_perfect_square>

=cut

=head2 is_square_free

Number.is_square_free() -> I<Obj>

Return the

Aliases: I<is_squarefree>

=cut

=head2 is_stronger_lucas_psp

Number.is_stronger_lucas_psp() -> I<Obj>

Return the

Aliases: I<is_extra_strong_lucas_psp>, I<is_stronger_lucas_pseudoprime>, I<is_extra_strong_lucas_pseudoprime>

=cut

=head2 is_strong_fib

Number.is_strong_fib() -> I<Obj>

Return the

Aliases: I<is_strong_fib_psp>, I<is_strong_fibonacci>, I<is_strong_fibonacci_psp>, I<is_strong_fibonacci_pseudoprime>

=cut

=head2 is_strongish_lucas_psp

Number.is_strongish_lucas_psp() -> I<Obj>

Return the

Aliases: I<is_strongish_lucas_pseudoprime>

=cut

=head2 is_strong_lucas_psp

Number.is_strong_lucas_psp() -> I<Obj>

Return the

Aliases: I<is_strong_lucas_pseudoprime>

=cut

=head2 is_strong_psp

Number.is_strong_psp() -> I<Obj>

Return the

Aliases: I<miller_rabin>, I<is_strong_fermat_psp>, I<is_strong_pseudoprime>, I<is_strong_fermat_pseudoprime>

=cut

=head2 is_super_psp

Number.is_super_psp() -> I<Obj>

Return the

Aliases: I<is_super_pseudoprime>, I<is_superpseudoprime>

=cut

=head2 is_totient

Number.is_totient() -> I<Obj>

Return the

=cut

=head2 isub

Number.isub() -> I<Obj>

Return the

=cut

=head2 is_underwood_psp

Number.is_underwood_psp() -> I<Obj>

Return the

Aliases: I<is_underwood_pseudoprime>, I<is_frobenius_underwood_psp>, I<is_frobenius_underwood_pseudoprime>

=cut

=head2 is_zero

Number.is_zero() -> I<Obj>

Return the

=cut

=head2 jacobi

Number.jacobi() -> I<Obj>

Return the

=cut

=head2 jordan_totient

Number.jordan_totient() -> I<Obj>

Return the

=cut

=head2 kronecker

Number.kronecker() -> I<Obj>

Return the

=cut

=head2 laguerre

Number.laguerre() -> I<Obj>

Return the

Aliases: I<laguerreL>, I<laguerre_polynomial>

=cut

=head2 lambda

    lambda(n)

Carmichael lambda function: C<λ(n)>, defined as the smallest positive integer C<m> such that:

    aᵐ ≡ 1 (mod n)

for every integer C<a> between C<1> and C<n> that is coprime to C<n>.

Alias: I<carmichael_lambda>.

=cut

=head2 lambert_w

Number.lambert_w() -> I<Obj>

Return the

=cut

=head2 lcm

Number.lcm() -> I<Obj>

Return the

=cut

=head2 legendre

Number.legendre() -> I<Obj>

Return the

=cut

=head2 legendre_P

Number.legendre_P() -> I<Obj>

Return the

Aliases: I<legendrep>, I<legendreP>, I<legendre_polynomial>

=cut

=head2 len

Number.len() -> I<Obj>

Return the

Aliases: I<size>, I<length>

=cut

=head2 lgamma

Number.lgamma() -> I<Obj>

Return the

Aliases: I<gamma_abs_log>

=cut

=head2 lgrt

Number.lgrt() -> I<Obj>

Return the

=cut

=head2 li

Number.li() -> I<Obj>

Return the

=cut

=head2 li2

Number.li2() -> I<Obj>

Return the

=cut

=head2 liouville

Number.liouville() -> I<Obj>

Return the

=cut

=head2 liouville_sum

Number.liouville_sum() -> I<Obj>

Return the

=cut

=head2 ln

Number.ln() -> I<Obj>

Return the

=cut

=head2 ln2

Number.ln2() -> I<Obj>

Return the

=cut

=head2 lnbern

Number.lnbern() -> I<Obj>

Return the

Aliases: I<bern_log>, I<lnbernreal>, I<bernoulli_log>

=cut

=head2 lngamma

Number.lngamma() -> I<Obj>

Return the

Aliases: I<gamma_log>

=cut

=head2 lnsuperfactorial

Number.lnsuperfactorial() -> I<Obj>

Return the

Aliases: I<superfactorial_ln>, I<superfactorial_log>

=cut

=head2 log

Number.log() -> I<Obj>

Return the

=cut

=head2 log10

Number.log10() -> I<Obj>

Return the

=cut

=head2 log2

Number.log2() -> I<Obj>

Return the

=cut

=head2 logarithmic_derivative

Number.logarithmic_derivative() -> I<Obj>

Return the

=cut

=head2 lpf

Number.lpf() -> I<Obj>

Return the

=cut

=head2 lsb

Number.lsb() -> I<Obj>

Return the

=cut

=head2 lucas

Number.lucas() -> I<Obj>

Return the

=cut

=head2 lucas_factor

Number.lucas_factor() -> I<Obj>

Return the

Aliases: I<lucas_miller_factor>

=cut

=head2 lucas_mod

Number.lucas_mod() -> I<Obj>

Return the

Aliases: I<lucasmod>

=cut

=head2 lucas_U

Number.lucas_U() -> I<Obj>

Return the

Aliases: I<lucasu>, I<lucasU>

=cut

=head2 lucasumod

Number.lucasumod() -> I<Obj>

Return the

Aliases: I<lucasUmod>

=cut

=head2 lucasuvmod

Number.lucasuvmod() -> I<Obj>

Return the

Aliases: I<lucasUVmod>

=cut

=head2 lucas_V

Number.lucas_V() -> I<Obj>

Return the

Aliases: I<lucasv>, I<lucasV>

=cut

=head2 lucasvmod

Number.lucasvmod() -> I<Obj>

Return the

Aliases: I<lucasVmod>

=cut

=head2 make_coprime

Number.make_coprime() -> I<Obj>

Return the

=cut

=head2 mangoldt

Number.mangoldt() -> I<Obj>

Return the

=cut

=head2 max

Number.max() -> I<Obj>

Return the

=cut

=head2 mertens

Number.mertens() -> I<Obj>

Return the

=cut

=head2 mfac

Number.mfac() -> I<Obj>

Return the

Aliases: I<mfactorial>, I<multi_factorial>

=cut

=head2 miller_factor

Number.miller_factor() -> I<Obj>

Return the

Aliases: I<miller_rabin_factor>

=cut

=head2 miller_rabin_random

Number.miller_rabin_random() -> I<Obj>

Return the

=cut

=head2 min

Number.min() -> I<Obj>

Return the

=cut

=head2 mone

Number.mone() -> I<Obj>

Return the

=cut

=head2 motzkin

Number.motzkin() -> I<Obj>

Return the

=cut

=head2 msb

Number.msb() -> I<Obj>

Return the

=cut

=head2 mulmod

Number.mulmod() -> I<Obj>

Return the

=cut

=head2 multinomial

Number.multinomial() -> I<Obj>

Return the

=cut

=head2 nan

Number.nan() -> I<Obj>

Return the

=cut

=head2 nd

Number.nd() -> I<Obj>

Return the

Aliases: I<rd>, I<st>, I<th>

=cut

=head2 neg

Number.neg() -> I<Obj>

Return the

=cut

=head2 new

Number.new() -> I<Obj>

Return the

Aliases: I<call>

=cut

=head2 next_composite

Number.next_composite() -> I<Obj>

Return the

=cut

=head2 next_palindrome

Number.next_palindrome() -> I<Obj>

Return the

=cut

=head2 next_pow

Number.next_pow() -> I<Obj>

Return the

Aliases: I<next_power>

=cut

=head2 next_pow2

Number.next_pow2() -> I<Obj>

Return the

Aliases: I<next_power2>

=cut

=head2 next_prime

Number.next_prime() -> I<Obj>

Return the

=cut

=head2 next_twin_prime

Number.next_twin_prime() -> I<Obj>

Return the

=cut

=head2 ninf

Number.ninf() -> I<Obj>

Return the

=cut

=head2 nok

Number.nok() -> I<Obj>

Return the

Aliases: I<binomial>

=cut

=head2 norm

Number.norm() -> I<Obj>

Return the

=cut

=head2 n_primes

Number.n_primes() -> I<Obj>

Return the

=cut

=head2 nu

Number.nu() -> I<Obj>

Return the

Aliases: I<numerator>

=cut

=head2 nude

Number.nude() -> I<Obj>

Return the

=cut

=head2 num2perm

Number.num2perm() -> I<Obj>

Return the

=cut

=head2 numify

Number.numify() -> I<Obj>

Return the

=cut

=head2 of

Number.of() -> I<Obj>

Return the

=cut

=head2 one

Number.one() -> I<Obj>

Return the

=cut

=head2 partitions

Number.partitions() -> I<Obj>

Return the

Aliases: I<partition_number>

=cut

=head2 pbrent_factor

Number.pbrent_factor() -> I<Obj>

Return the

=cut

=head2 perfect_power

Number.perfect_power() -> I<Obj>

Return the

=cut

=head2 perfect_root

Number.perfect_root() -> I<Obj>

Return the

=cut

=head2 permutations

Number.permutations() -> I<Obj>

Return the

=cut

=head2 pi_k

Number.pi_k() -> I<Obj>

Return the

Aliases: I<k_prime_count>, I<almost_primepi>, I<almost_prime_count>

=cut

=head2 pm1_factor

Number.pm1_factor() -> I<Obj>

Return the

Aliases: I<pminus1_factor>

=cut

=head2 pn_primes

Number.pn_primes() -> I<Obj>

Return the

=cut

=head2 pn_primorial

Number.pn_primorial() -> I<Obj>

Return the

=cut

=head2 polygonal

Number.polygonal() -> I<Obj>

Return the

=cut

=head2 polygonal_root

Number.polygonal_root() -> I<Obj>

Return the

=cut

=head2 polygonal_root2

Number.polygonal_root2() -> I<Obj>

Return the

=cut

=head2 polymod

Number.polymod() -> I<Obj>

Return the

=cut

=head2 popcount

Number.popcount() -> I<Obj>

Return the

Aliases: I<hammingweight>

=cut

=head2 power_count

Number.power_count() -> I<Obj>

Return the

Aliases: I<perfect_power_count>

=cut

=head2 powerful

Number.powerful() -> I<Obj>

Return the

=cut

=head2 powerful_count

Number.powerful_count() -> I<Obj>

Return the

=cut

=head2 pp1_factor

Number.pp1_factor() -> I<Obj>

Return the

Aliases: I<pplus1_factor>

=cut

=head2 prev_prime

Number.prev_prime() -> I<Obj>

Return the

=cut

=head2 prho_factor

Number.prho_factor() -> I<Obj>

Return the

=cut

=head2 primality_pretest

Number.primality_pretest() -> I<Obj>

Return the

=cut

=head2 prime

Number.prime() -> I<Obj>

Return the

Aliases: I<nth_prime>

=cut

=head2 prime_divisors

Number.prime_divisors() -> I<Obj>

Return the

=cut

=head2 primepi

Number.primepi() -> I<Obj>

Return the

Aliases: I<prime_count>

=cut

=head2 primepi_lower

Number.primepi_lower() -> I<Obj>

Return the

Aliases: I<prime_count_lower>

=cut

=head2 primepi_upper

Number.primepi_upper() -> I<Obj>

Return the

Aliases: I<prime_count_upper>

=cut

=head2 prime_power

Number.prime_power() -> I<Obj>

Return the

=cut

=head2 prime_power_count

Number.prime_power_count() -> I<Obj>

Return the

=cut

=head2 prime_power_divisors

Number.prime_power_divisors() -> I<Obj>

Return the

=cut

=head2 prime_power_sigma

Number.prime_power_sigma() -> I<Obj>

Return the

=cut

=head2 prime_power_udivisors

Number.prime_power_udivisors() -> I<Obj>

Return the

Aliases: I<prime_power_unitary_divisors>, I<unitary_prime_power_divisors>

=cut

=head2 prime_power_usigma

Number.prime_power_usigma() -> I<Obj>

Return the

=cut

=head2 prime_root

Number.prime_root() -> I<Obj>

Return the

=cut

=head2 primes

Number.primes() -> I<Obj>

Return the

=cut

=head2 prime_sigma

Number.prime_sigma() -> I<Obj>

Return the

=cut

=head2 primes_sum

Number.primes_sum() -> I<Obj>

Return the

Aliases: I<sum_primes>

=cut

=head2 prime_udivisors

Number.prime_udivisors() -> I<Obj>

Return the

Aliases: I<prime_unitary_divisors>, I<unitary_prime_divisors>

=cut

=head2 prime_usigma

Number.prime_usigma() -> I<Obj>

Return the

=cut

=head2 prime_usigma0

Number.prime_usigma0() -> I<Obj>

Return the

=cut

=head2 primitive_part

Number.primitive_part() -> I<Obj>

Return the

=cut

=head2 primorial

Number.primorial() -> I<Obj>

Return the

=cut

=head2 primorial_deflation

Number.primorial_deflation() -> I<Obj>

Return the

=cut

=head2 primorial_inflation

Number.primorial_inflation() -> I<Obj>

Return the

=cut

=head2 psi

Number.psi() -> I<Obj>

Return the

Aliases: I<dedekind_psi>

=cut

=head2 qnr

Number.qnr() -> I<Obj>

Return the

Aliases: I<quadratic_nonresidue>

=cut

=head2 qs_factor

Number.qs_factor() -> I<Obj>

Return the

=cut

=head2 quadratic_formula

Number.quadratic_formula() -> I<Obj>

Return the

=cut

=head2 rad

Number.rad() -> I<Obj>

Return the

=cut

=head2 rad2deg

Number.rad2deg() -> I<Obj>

Return the

=cut

=head2 ramanujan_sum

Number.ramanujan_sum() -> I<Obj>

Return the

=cut

=head2 ramanujan_tau

Number.ramanujan_tau() -> I<Obj>

Return the

=cut

=head2 rand

Number.rand() -> I<Obj>

Return the

=cut

=head2 random_bytes

Number.random_bytes() -> I<Obj>

Return the

=cut

=head2 random_maurer_nbit_prime

Number.random_maurer_nbit_prime() -> I<Obj>

Return the

Aliases: I<random_nbit_maurer_prime>

=cut

=head2 random_nbit_prime

Number.random_nbit_prime() -> I<Obj>

Return the

=cut

=head2 random_nbit_strong_prime

Number.random_nbit_strong_prime() -> I<Obj>

Return the

Aliases: I<random_strong_nbit_prime>

=cut

=head2 random_ndigit_prime

Number.random_ndigit_prime() -> I<Obj>

Return the

=cut

=head2 random_prime

Number.random_prime() -> I<Obj>

Return the

=cut

=head2 random_safe_prime

Number.random_safe_prime() -> I<Obj>

Return the

=cut

=head2 random_string

Number.random_string() -> I<Obj>

Return the

=cut

=head2 range

Number.range() -> I<Obj>

Return the

=cut

=head2 rat

Number.rat() -> I<Obj>

Return the

Aliases: I<to_r>, I<to_rat>

=cut

=head2 rat_approx

Number.rat_approx() -> I<Obj>

Return the

=cut

=head2 ratmod

Number.ratmod() -> I<Obj>

Return the

=cut

=head2 re

Number.re() -> I<Obj>

Return the

Aliases: I<real>

=cut

=head2 reals

Number.reals() -> I<Obj>

Return the

=cut

=head2 remdiv

Number.remdiv() -> I<Obj>

Return the

Aliases: I<remove>

=cut

=head2 rising_factorial

Number.rising_factorial() -> I<Obj>

Return the

=cut

=head2 root

Number.root() -> I<Obj>

Return the

=cut

=head2 rough_count

Number.rough_count() -> I<Obj>

Return the

=cut

=head2 rough_part

Number.rough_part() -> I<Obj>

Return the

=cut

=head2 round

Number.round() -> I<Obj>

Return the

Aliases: I<roundf>

=cut

=head2 run

Number.run() -> I<Obj>

Return the

=cut

=head2 sec

Number.sec() -> I<Obj>

Return the

=cut

=head2 secant_number

Number.secant_number() -> I<Obj>

Return the

=cut

=head2 sech

Number.sech() -> I<Obj>

Return the

=cut

=head2 seed

Number.seed() -> I<Obj>

Return the

=cut

=head2 semiprime

Number.semiprime() -> I<Obj>

Return the

Aliases: I<nth_semiprime>

=cut

=head2 semiprime_count

Number.semiprime_count() -> I<Obj>

Return the

=cut

=head2 setbit

Number.setbit() -> I<Obj>

Return the

=cut

=head2 sgn

Number.sgn() -> I<Obj>

Return the

Aliases: I<sign>

=cut

=head2 sigma0

Number.sigma0() -> I<Obj>

Return the

=cut

=head2 sin

Number.sin() -> I<Obj>

Return the

=cut

=head2 sin_cos

Number.sin_cos() -> I<Obj>

Return the

=cut

=head2 sinh

Number.sinh() -> I<Obj>

Return the

=cut

=head2 smooth_count

Number.smooth_count() -> I<Obj>

Return the

=cut

=head2 smooth_part

Number.smooth_part() -> I<Obj>

Return the

=cut

=head2 solve_pell

Number.solve_pell() -> I<Obj>

Return the

=cut

=head2 sopf

Number.sopf() -> I<Obj>

Return the

=cut

=head2 sopfr

Number.sopfr() -> I<Obj>

Return the

=cut

=head2 sqr

Number.sqr() -> I<Obj>

Return the

=cut

=head2 sqrt

Number.sqrt() -> I<Obj>

Return the

=cut

=head2 sqrt_cfrac

Number.sqrt_cfrac() -> I<Obj>

Return the

=cut

=head2 sqrt_cfrac_period

Number.sqrt_cfrac_period() -> I<Obj>

Return the

=cut

=head2 sqrt_cfrac_period_len

Number.sqrt_cfrac_period_len() -> I<Obj>

Return the

=cut

=head2 sqrtmod

Number.sqrtmod() -> I<Obj>

Return the

=cut

=head2 square_divisors

Number.square_divisors() -> I<Obj>

Return the

=cut

=head2 squarefree

Number.squarefree() -> I<Obj>

Return the

=cut

=head2 square_free_count

Number.square_free_count() -> I<Obj>

Return the

Aliases: I<squarefree_count>

=cut

=head2 squarefree_divisors

Number.squarefree_divisors() -> I<Obj>

Return the

=cut

=head2 squarefree_sigma

Number.squarefree_sigma() -> I<Obj>

Return the

=cut

=head2 squarefree_udivisors

Number.squarefree_udivisors() -> I<Obj>

Return the

Aliases: I<squarefree_unitary_divisors>, I<unitary_squarefree_divisors>

=cut

=head2 squarefree_usigma

Number.squarefree_usigma() -> I<Obj>

Return the

=cut

=head2 squarefree_usigma0

Number.squarefree_usigma0() -> I<Obj>

Return the

=cut

=head2 square_sigma

Number.square_sigma() -> I<Obj>

Return the

=cut

=head2 square_sigma0

Number.square_sigma0() -> I<Obj>

Return the

=cut

=head2 square_udivisors

Number.square_udivisors() -> I<Obj>

Return the

Aliases: I<square_unitary_divisors>, I<unitary_square_divisors>

=cut

=head2 square_usigma

Number.square_usigma() -> I<Obj>

Return the

=cut

=head2 square_usigma0

Number.square_usigma0() -> I<Obj>

Return the

=cut

=head2 squfof_factor

Number.squfof_factor() -> I<Obj>

Return the

=cut

=head2 stirling

Number.stirling() -> I<Obj>

Return the

Aliases: I<stirling1>

=cut

=head2 stirling2

Number.stirling2() -> I<Obj>

Return the

=cut

=head2 stirling3

Number.stirling3() -> I<Obj>

Return the

=cut

=head2 subfactorial

Number.subfactorial() -> I<Obj>

Return the

=cut

=head2 submod

Number.submod() -> I<Obj>

Return the

=cut

=head2 subsets

Number.subsets() -> I<Obj>

Return the

=cut

=head2 superfactorial

Number.superfactorial() -> I<Obj>

Return the

=cut

=head2 superprimorial

Number.superprimorial() -> I<Obj>

Return the

=cut

=head2 tan

Number.tan() -> I<Obj>

Return the

=cut

=head2 tangent_number

Number.tangent_number() -> I<Obj>

Return the

=cut

=head2 tanh

Number.tanh() -> I<Obj>

Return the

=cut

=head2 times

Number.times() -> I<Obj>

Return the

=cut

=head2 to_f

Number.to_f() -> I<Obj>

Return the

Aliases: I<float>, I<to_float>

=cut

=head2 to_n

Number.to_n() -> I<Obj>

Return the

Aliases: I<to_num>

=cut

=head2 to_s

Number.to_s() -> I<Obj>

Return the

Aliases: I<to_str>

=cut

=head2 totient

Number.totient() -> I<Obj>

Return the

Aliases: I<euler_phi>, I<eulerphi>, I<euler_totient>

=cut

=head2 trial_factor

Number.trial_factor() -> I<Obj>

Return the

=cut

=head2 tuples

Number.tuples() -> I<Obj>

Return the

Aliases: I<variations>

=cut

=head2 tuples_with_repetition

Number.tuples_with_repetition() -> I<Obj>

Return the

Aliases: I<variations_with_repetition>

=cut

=head2 udivisors

Number.udivisors() -> I<Obj>

Return the

Aliases: I<unitary_divisors>

=cut

=head2 uphi

Number.uphi() -> I<Obj>

Return the

=cut

=head2 usigma

Number.usigma() -> I<Obj>

Return the

=cut

=head2 usigma0

Number.usigma0() -> I<Obj>

Return the

Aliases: I<squarefree_sigma0>

=cut

=head2 valuation

Number.valuation() -> I<Obj>

Return the

=cut

=head2 zero

Number.zero() -> I<Obj>

Return the

=cut

=head2 znorder

Number.znorder() -> I<Obj>

Return the

=cut

=head2 znprimroot

Number.znprimroot() -> I<Obj>

Return the

=cut
