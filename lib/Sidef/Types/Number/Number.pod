
=encoding utf8

=head1 NAME

Sidef::Types::Number::Number

=head1 DESCRIPTION

The C<Number> class implements support for numerical operations, supporting integers, rationals, floating-points and complex numbers at arbitrary precision.

This class also implements many useful mathematical methods, from basic arithmetical operations, to advanced number-theoretic functions, including primality testing and prime factorization methods.

=head1 SYNOPSIS

    var a = Num(string)
    var b = Number(string, base)

=head1 INHERITS

Inherits methods from:

       * Sidef::Object::Object

=head1 METHODS

=head2 !

    n!

Factorial of C<n>. (C<1*2*3*...*n>)

Aliases: I<fac>, I<factorial>

=cut

=head2 !!

    n!!

Double-factorial of C<n>.

Aliases: I<dfac>, I<dfactorial>, I<double_factorial>

=cut

=head2 %

    n % k

Remainder of C<n/k>.

Aliases: I<mod>

=cut

=head2 %%

    n %% k

Returns true if C<n> is divisible by C<k>. False otherwise.

Aliases: I<is_div>

=cut

=head2 &

    a & b

Bitwise AND operation.

Aliases: I<and>

=cut

=head2 *

    a * b

Multiplication of C<a> and C<b>.

Aliases: I<mul>

=cut

=head2 **

    a**b

Exponentiation: C<a> to power C<b>.

Aliases: I<pow>

=cut

=head2 +

    a + b

Addition of C<a> and C<b>.

Aliases: I<add>

=cut

=head2 ++

    n.inc

Increment C<n> by C<1> and return the result.

Aliases: I<inc>

=cut

=head2 -

    a - b

Subtraction of C<a> and C<b>.

Aliases: I<sub>

=cut

=head2 --

    n.dec

Decrement C<n> by C<1> and return the result.

Aliases: I<dec>

=cut

=head2 ..

    a .. b

Create an inclusive-inclusive C<RangeNum> object, from C<a> to C<b>.

Equivalent with:

    RangeNum(a, b)

Aliases: I<to>, I<upto>

=cut

=head2 ..^

    a ..^ b

Create an inclusive-exclusive C<RangeNum> object, from C<a> to C<b-1>.

Equivalent with:

    RangeNum(a, b-1)

Aliases: I<xto>, I<xupto>

=cut

=head2 /

    a / b

Division of C<a> by C<b>.

Aliases: I<÷>, I<div>

=cut

=head2 //

    a // b

Integer floor-division of C<a> and C<b>.

Equivalent with:

    floor(a/b)

Aliases: I<idiv>

=cut

=head2 :

    a : b

Create a new complex number.

Equivalent with:

    Complex(a, b)

Aliases: I<pair>

=cut

=head2 <

    a < b

Returns true if C<a> is less than C<b>.

Aliases: I<lt>

=cut

=head2 <<

    a << b

Left shift C<a> by C<b> bits, which is equivalent with (assuming C<a> and C<b> are integers):

    floor(a * 2**b)

Aliases: I<lsft>, I<shift_left>

=cut

=head2 <=>

    a <=> b

Comparison of C<a> with C<b>. Returns C<-1> if C<a> is less than C<b>, C<0> if C<a> and C<b> are equal and C<+1> if C<a> is greater than C<b>.

Aliases: I<cmp>

=cut

=head2 approx_cmp

    approx_cmp(a, b)
    approx_cmp(a, b, k)

Approximate comparison of C<a> and C<b>.

Equivalent with:

    a.round(k) <=> b.round(k)

When C<k> is omitted, it uses the default floating-point precision to deduce C<k>.

=cut

=head2 ==

    a == b

Equality check. Returns true if C<a> and C<b> are equal.

Aliases: I<eq>

=cut

=head2 >

    a > b

Returns true if C<a> is greater than C<b>. False otherwise.

Aliases: I<gt>

=cut

=head2 >>

    a >> b

Right shift C<a> by C<b> bits, which is equivalent with (assuming C<a> and C<b> are integers):

    floor(a / 2**b)

Aliases: I<rsft>, I<shift_right>

=cut

=head2 ^

    a ^ b

Bitwise XOR operation.

Aliases: I<xor>

=cut

=head2 ^..

    a ^.. b

Creates a reversed exclusive-inclusive C<RangeNum> object, from C<a-1> down to C<b>.

Equivalent with:

    RangeNum(a-1, b, -1)

Aliases: I<xdownto>

=cut

=head2 C

    Num.C
    Num.catalan_G

Returns the Catalan constant: 0.915965594177...

Aliases: I<catalan_G>

=cut

=head2 Y

    Number.Y()

Return the

Aliases: I<γ>, I<euler_gamma>

=cut

=head2 |

    I<Obj> B<|> I<Obj>

Return the

Aliases: I<or>

=cut

=head2 ~

    I<Obj> B<~> I<Obj>

Return the

Aliases: I<not>

=cut

=head2 Γ

    Number.Γ()

Return the

Aliases: I<gamma>

=cut

=head2 δ

    δ(a,b)

The Kronecker delta function, which returns 1 iff `a==b` and 0 otherwise.

Aliases: I<kronecker_delta>

=cut

=head2 ζ

    Number.ζ()

Return the

Aliases: I<zeta>

=cut

=head2 η

    Number.η()

Return the

Aliases: I<eta>

=cut

=head2 μ

    Number.μ()

Return the

Aliases: I<mu>, I<mobius>, I<möbius>, I<moebius>

=cut

=head2 Π

    Π(...)
    prod(...)

Return the product of a given list of numbers.

Aliases: I<prod>

=cut

=head2 π

    π(n)
    π(a,b)
    Num.π

Returns the PI numerical value:

    say Num.pi      #=> 3.1415...

When applied on a Number object (as C<n.pi> or C<pi(n)>), it returns the number of primes <= n:

    say 100.pi      #=> number of primes <= 100
    say pi(100)     #=> 25

When an additional argument is given, it returns the number of primes in the range a..b:

    say pi(50, 100)     # number of primes in the range 50..100

Aliases: I<pi>

=cut

=head2 Σ

    Σ(...)
    sum(...)

Return the sum of a given list of numbers.

Aliases: I<sum>

=cut

=head2 σ

    Number.σ()

Return the

Aliases: I<sigma>

=cut

=head2 τ

    Number.τ()

Return the

Aliases: I<tau>

=cut

=head2 φ

    Number.φ()

Return the

Aliases: I<phi>

=cut

=head2 Ψ

    Number.Ψ()

Return the

Aliases: I<digamma>

=cut

=head2 Ω

    Number.Ω()

Return the

Aliases: I<bigomega>, I<prime_power_sigma0>

=cut

=head2 ω

    Number.ω()

Return the

Aliases: I<omega>, I<prime_sigma0>, I<prime_power_usigma0>

=cut

=head2 ≅

    I<Obj> B<≅> I<Obj>

Return the

Aliases: I<=~=>, I<approx_eq>

=cut

=head2 ≠

    I<Obj> B<≠> I<Obj>

Return the

Aliases: I<!=>, I<ne>

=cut

=head2 ≤

    I<Obj> B<≤> I<Obj>

Return the

Aliases: I<E<lt>=>, I<le>

=cut

=head2 ≥

    I<Obj> B<≥> I<Obj>

Return the

Aliases: I<E<gt>=>, I<ge>

=cut

=head2 abs

    n.abs

Absolute value of C<n>.

=cut

=head2 abundancy

    Number.abundancy()

Return the

Aliases: I<abundancy_index>

=cut

=head2 acmp

    Number.acmp()

Return the

=cut

=head2 acos

    n.acos

Inverse cosine of C<n> in radians.

=cut

=head2 acosh

    n.acosh

Inverse hyperbolic cosine of C<n>.

=cut

=head2 acot

    n.acot

Inverse cotangent of C<n> in radians.

=cut

=head2 acoth

    n.acoth

Inverse hyperbolic cotangent of C<n>.

=cut

=head2 acsc

    n.acsc

Inverse cosecant of C<n> in radians.

=cut

=head2 acsch

    n.acsch

Inverse hyperbolic cosecant of C<n>.

=cut

=head2 addmod

    addmod(a, b, m)

Returns C<(a+b) % m>.

Example:

    say addmod(43, 97, 127)     # == (43+97)%127

=cut

=head2 agm

    agm(a, b)

Arithmetic-geometric mean of C<a> and C<b>.

=cut

=head2 ai

    x.ai
    Ai(x)

Airy function of the first kind: C<Ai(x)>.

Aliases: I<airy>

=cut

=head2 all_composite

    all_composite(...)

Returns true if all the given values are composite positive integers, by checking first for small factors, then running a B-PSW primality test.

=cut

=head2 all_prime

    all_prime(...)

Returns true if all the given values are prime numbers.

This is done by first running a primality pre-test on all values and returning early if one of the values is composite with a small factor. Otherwise, we run a B-PSW primality test on each value.

=cut

=head2 almost_primes

k.almost_primes(n)
k.almost_primes(a,b)

Return an array with the k-almost primes <= n, or in the range a..b.

Example:

    5.almost_primes(1e6)        # array of 5-almost primes <= 1e6
    5.almost_primes(1e5, 1e6)   # array of 5-almost primes in the range [1e5, 1e6]

=cut

=head2 approx_ge

    approx_ge(a, b)
    approx_ge(a, b, k)

True if C<a> is approximately greater than or equal to C<b>.

Equivalent with:

    a.round(k) >= b.round(k)

=cut

=head2 approx_gt

    approx_gt(a, b)
    approx_gt(a, b, k)

True if C<a> is approximately greater than C<b>.

Equivalent with:

    a.round(k) > b.round(k)

=cut

=head2 approx_le

    approx_le(a, b)
    approx_le(a, b, k)

True if C<a> is approximately less than or equal to C<b>.

Equivalent with:

    a.round(k) <= b.round(k)

=cut

=head2 approx_lt

    approx_lt(a, b)
    approx_lt(a, b, k)

True if C<a> is approximately less than C<b>.

Equivalent with:

    a.round(k) < b.round(k)

=cut

=head2 approx_ne

    approx_ne(a, b)
    approx_ne(a, b, k)

True if C<a> is approximately different than C<b>.

Equivalent with:

    a.round(k) != b.round(k)

=cut

=head2 as_bin

    n.as_bin

Returns a C<String> with the binary representation of C<n>.

Example:

    say 42.as_bin     # "101011"

=cut

=head2 as_dec

    n.as_dec
    n.as_dec(k)

Given a rational number C<n>, it returns its decimal expansion as a C<String> object, expanded at C<k> decimal places.

Example:

    say (1/17 -> as_dec(10))      # 0.05882352941
    say (1/17 -> as_dec(30))      # 0.0588235294117647058823529411765

Aliases: I<as_float>

=cut

=head2 asec

    n.asec

Inverse secant of C<n> in radians.

=cut

=head2 asech

    n.asech

Inverse hyperbolic secant of C<n>.

=cut

=head2 as_frac

    n.as_frac
    n.as_frac(base)

String-representation of C<n> as fraction.

Example:

    say 24.as_frac                 # 24/1
    say bernoulli(10).as_frac      # 5/66
    say bernoulli(12).as_frac(36)  # -j7/23u

If C<n> is an integer, it uses C<1> for the denominator.

=cut

=head2 as_hex

    n.as_hex

Returns a String representing the integer part of C<n> in hexadecimal (base 16).

Example:

    say 42.as_hex       # "2a"

Returns C<nil> when C<n> cannot be converted to an integer.

=cut

=head2 asin

    n.asin

Inverse sine of C<n> in radians.

=cut

=head2 asinh

    n.asinh

Inverse hyperbolic sine of C<n>.

=cut

=head2 as_int

    n.as_int
    n.as_int(base)

Returns a String representing the integer part of C<n> in a given base, where the base must be between 2 and 62.

When the base is omitted, it defaults to base 10.

Example:

    say 255.as_int      # "255"
    say 255.as_int(16)  # "ff"

Returns C<nil> when C<n> cannot be converted to an integer.

=cut

=head2 as_oct

    n.as_oct

Returns a String representing the integer part of C<n> in octal (base 8).

Example:

    say 42.as_oct   # 52

Returns C<nil> when C<n> cannot be converted to an integer.

=cut

=head2 as_rat

    n.as_rat
    n.as_rat(base)

Returns a rational string-representation of C<n> in a given base, where the base must be between 2 and 62.

When the base is omitted, it defaults to base 10.

Example:

    say as_rat(42)          # "42"
    say as_rat(2/4)         # "1/2"
    say as_rat(255, 16)     # "ff"

Returns C<nil> when C<n> cannot be converted to a rational number.

=cut

=head2 atan

    n.atan

Inverse tangent of C<n> in radians.

=cut

=head2 atan2

    atan2(a, b)

Four-quadrant inverse tangent of C<a> and C<b>.

=cut

=head2 atanh

    n.atanh

Inverse hyperbolic tangent of C<n>.

=cut

=head2 base

    n.base(b)

Returns a String-representation of C<n> in a given base C<b>, which must be between 2 and 62.

Aliases: I<in_base>

=cut

=head2 bell

    n.bell

Returns the n-th Bell number.

Aliases: I<bell_number>

=cut

=head2 bern

    n.bern
    bernoulli(n)
    bernoulli(n, x)

Returns the n-th Bernoulli number. When an additional argument is provided, it returns the n-th Bernoulli polynomial.

Example:

    say bernoulli(10).as_rat       # B_10    = 5/66
    say bernoulli(10, 2).as_rat    # B_10(2) = 665/66

Aliases: I<bernfrac>, I<bernoulli>, I<bernoulli_number>

=cut

=head2 bernoulli_polynomial

    bernoulli_polynomial(n, x)

Returns the n-th Bernoulli polynomial: C<B_n(x)>.

=cut

=head2 bernreal

    n.bernreal

Return an approximation to the n-th Bernoulli number as a floating-point number.

=cut

=head2 bessel_j

    bessel_j(x, n)

First order Bessel function: C<J_n(x)>.

=cut

=head2 bessel_y

    bessel_y(x, n)

Second order Bessel function: C<Y_n(x)>.

=cut

=head2 beta

    beta(a, b)

The beta function (also called the Euler integral of the first kind).

Defined as:

    beta(a, b) = gamma(a)*gamma(b) / gamma(a+b)

=cut

=head2 bit

    n.bit(k)
    n.getbit(k)

Returns 1 if bit C<k> of C<n> is set, and 0 if it is not set.

Return C<nil> when C<n> cannot be truncated to an integer or when C<k> is negative.

Example:

    say getbit(0b1001, 0)   # 1
    say getbit(0b1000, 0)   # 0

Aliases: I<getbit>, I<testbit>

=cut

=head2 bits

    n.bits()

Returns the binary digits of n.

The bits are ordered from the most significant bit to the least significant bit.

Example:

    say 1234.bits       #=> [1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0]

Equilvalent with:

    n.digits(2).flip

=cut

=head2 bit_scan0

    n.bit_scan0
    n.bit_scan0(k)

Scan C<n>, starting from bit index C<k>, towards more significant bits, until a 0-bit is found.

When C<k> is omitted, C<k=0> is assumed.

Returns C<nil> if C<n> cannot be truncated to an integer or if C<k> is negative.

=cut

=head2 bit_scan1

    n.bit_scan1
    n.bit_scan1(k)

Scan C<n>, starting from bit index C<k>, towards more significant bits, until a 1-bit is found.

When C<k> is omitted, C<k=0> is assumed.

Returns C<nil> if C<n> cannot be truncated to an integer or if C<k> is negative.

=cut

=head2 bsearch

    bsearch(n, {...})
    bsearch(a, b, {...})

Binary search from to C<0> to C<n>, or from C<a> to C<b>, which can be any arbitrary large integers.

The last argument is a block which does the comparisons.

This function finds a value C<k> such that f(k) = 0. Returns C<nil> otherwise.

    say bsearch(20,      {|k| k*k  <=> 49   })   #=> 7   (7*7  = 49)
    say bsearch(3, 1000, {|k| k**k <=> 3125 })   #=> 5   (5**5 = 3125)

=cut

=head2 bsearch_ge

    bsearch_ge(n, {...})
    bsearch_ge(a, b, {...})

Binary search from to C<0> to C<n>, or from C<a> to C<b>, which can be any arbitrary large integers.

The last argument is a block which does the comparisons.

This function finds a value C<k> such that f(k-1) < 0 and f(k) >= 0. Returns C<nil> otherwise.

    bsearch_ge(1e6,       { .exp <=> 1e+9 })  #  21   (exp( 21) >= 1e+9)
    bsearch_ge(-1e6, 1e6, { .exp <=> 1e-9 })  # -20   (exp(-20) >= 1e-9)

=cut

=head2 bsearch_le

    bsearch_le(n, {...})
    bsearch_le(a, b, {...})

Binary search from to C<0> to C<n>, or from C<a> to C<b>, which can be any arbitrary large integers.

The last argument is a block which does the comparisons.

This function finds a value C<k> such that f(k) <= 0 and f(k+1) > 0. Returns C<nil> otherwise.

    bsearch_le(1e6,       { .exp <=> 1e+9 })  #  20   (exp( 20) <= 1e+9)
    bsearch_le(-1e6, 1e6, { .exp <=> 1e-9 })  # -21   (exp(-21) <= 1e-9)

=cut

=head2 bsearch_max

    bsearch_max(n, {...})
    bsearch_max(a,b, {...})

Binary search, returning the minimum integer value in the range a..b that satisifes the given comparison function.

Example:

    say bsearch_max(1, 1e6, {|k| pi(k) <=> 100 })   #=> 546

where:

    n = 546 is the  largest value satisfying pi(n) <= 100

=cut

=head2 bsearch_min

    bsearch_min(n, {...})
    bsearch_min(a,b, {...})

Binary search, returning the minimum integer value in the range a..b that satisifes the given comparison function.

Example:

    say bsearch_min(1, 1e6, {|k| pi(k) <=> 100 })   #=> 541

where:

    n = 541 is the smallest value satisfying pi(n) >= 100

=cut

=head2 bsearch_solve

    bsearch_solve(n, {...})
    bsearch_solve(a,b, {...})

It computes the inverse of any continuous function, given the range that includes the inverse value.

For floating-point values, the `approx_cmp(a,b)` method (or the `<~>` operator) is recommended to be used for comparisons.

Example:

    say bsearch_inverse(100, {|x| exp(x) <~> 2 })          # solution to x for: exp(x) =   2
    say bsearch_inverse(200, {|x| x**2  <=> 43 })          # solution to x for:    x^2 =  43
    say bsearch_inverse(-10, 10, {|x| x**3 <~> -43 })      # solution to x for:    x^3 = -43
    say bsearch_inverse(300, 500, {|x| Li(x) <~> 100 })    # solution to x for:  Li(x) = 100

This method can also be used in computing approximations to some integer-specific functions:

    var n = 100000
    var v = 2*int(n*log(n) / log(log(n)))

    say nth_semiprime(n)                                        #=> 459577
    say bsearch_inverse(v, {|x| semiprime_count(x) <=> n })     #=> 459577.93302154541015625

Aliases: I<bsearch_inverse>

=cut

=head2 by

    Number.by()

Return the

Aliases: I<first>

=cut

=head2 cadd

    Number.cadd()

Return the

Aliases: I<complex_add>

=cut

=head2 catalan

    n.catalan
    n.catalan(k)

Returns the n-th Catalan number.

If two arguments are provided, it returns the C<C(n,k)> entry in Catalan's triangle.

=cut

=head2 cbrt

    n.cbrt

Cube root of C<n>.

=cut

=head2 cdiv

    Number.cdiv()

Return the

Aliases: I<complex_div>

=cut

=head2 ceil

    n.ceil

Round C<n> towards positive Infinity.

Aliases: I<ceiling>

=cut

=head2 cfrac

    n.cfrac
    n.cfrac(k)

Compute C<k> terms of the simple continued-fraction expansion of C<n>.

Example:

    say sqrt(12).cfrac(6)    # [3, 2, 6, 2, 6, 2, 6]

Can also be used to compute very good rational approximations to a given real number:

    say Num.pi.cfrac(10).flip.reduce{|a,b| b + 1/a }.as_rat      # 4272943/1360120

When C<k> is omitted, it uses the default floating-point precision to deduce C<k>.

Aliases: I<as_cfrac>

=cut

=head2 chebyshev_T

    chebyshevT(n, x)

Compute the Chebyshev polynomials of the first kind: C<T_n(x)>, where C<n> must be a native integer.

Defined as:

    T(0, x) = 1
    T(1, x) = x
    T(n, x) = 2*x*T(n-1, x) - T(n-2, x)

Aliases: I<chebyshevt>, I<chebyshevT>

=cut

=head2 chebyshev_U

    chebyshevU(n, x)

Compute the Chebyshev polynomials of the second kind: C<U_n(x)>, where C<n> must be a native integer.

Defined as:

    U(0, x) = 1
    U(1, x) = 2*x
    U(n, x) = 2*x*U(n-1, x) - U(n-2, x)

Aliases: I<chebyshevu>, I<chebyshevU>

=cut

=head2 chr

    n.chr

Convert the integer C<n> into a character.

Example:

    say 97.chr      # "a"
    say 9786.chr    # "☺"

=cut

=head2 cinv

    Number.cinv()

Return the

Aliases: I<complex_inv>

=cut

=head2 cinvmod

    Number.cinvmod()

Return the

Aliases: I<complex_invmod>

=cut

=head2 circular_permutations

    Number.circular_permutations()

Return the

=cut

=head2 cis

    Number.cis()

Return the

=cut

=head2 clearbit

    Number.clearbit()

Return the

=cut

=head2 cmod

    Number.cmod()

Return the

Aliases: I<complex_mod>

=cut

=head2 cmul

    Number.cmul()

Return the

Aliases: I<complex_mul>

=cut

=head2 combinations

    Number.combinations()

Return the

=cut

=head2 combinations_with_repetition

    Number.combinations_with_repetition()

Return the

=cut

=head2 commify

    Number.commify()

Return the

=cut

=head2 complex

    Number.complex()

Return the

=cut

=head2 complex_cmp

    Number.complex_cmp()

Return the

=cut

=head2 complex_ipow

    Number.complex_ipow()

Return the

=cut

=head2 composite

    n.composite()

Return the n-th composite number (OEIS: A002808).

Example:

    say composite(10**9)        #=> 1053422339

Aliases: I<nth_composite>

=cut

=head2 composite_count

composite_count(n)
composite_count(a,b)

Returns the number of composite numbers <= n, or in the range a..b.

Example:

    say composite_count(100)          # number of composites <= 100
    say composite_count(50, 100)      # number of composites in the range 50..100

=cut

=head2 conj

    Number.conj()

Return the

=cut

=head2 consecutive_lcm

    Number.consecutive_lcm()

Return the

Aliases: I<consecutive_integer_lcm>

=cut

=head2 convergents

    Number.convergents()

Return the

=cut

=head2 core

    n.core()

Squarefree part of n.

Example:

    say 30.of { .core }     #=> OEIS: A007913

Similar to PARI/GP `core(n)` function.

=cut

=head2 cos

    Number.cos()

Return the

=cut

=head2 cosh

    Number.cosh()

Return the

=cut

=head2 cot

    Number.cot()

Return the

=cut

=head2 coth

    Number.coth()

Return the

=cut

=head2 cpow

    Number.cpow()

Return the

Aliases: I<complex_pow>

=cut

=head2 cpowmod

    Number.cpowmod()

Return the

Aliases: I<complex_powmod>

=cut

=head2 csc

    Number.csc()

Return the

=cut

=head2 csch

    Number.csch()

Return the

=cut

=head2 csub

    Number.csub()

Return the

Aliases: I<complex_sub>

=cut

=head2 cyclotomic

    Number.cyclotomic()

Return the

Aliases: I<cyclotomic_polynomial>

=cut

=head2 dconv

    n.dconv(f,g)

Return the Dirichlet convolution of f and g.

Example:

    say 20.of { .dirichlet_convolution({.moebius}, {_}) }

Aliases: I<dirichlet_convolution>

=cut

=head2 de

    Number.de()

Return the

Aliases: I<denominator>

=cut

=head2 defs

    Number.defs()

Return the

=cut

=head2 deg2rad

    Number.deg2rad()

Return the

=cut

=head2 derangements

    Number.derangements()

Return the

Aliases: I<complete_permutations>

=cut

=head2 derivative

    Number.derivative()

Return the

Aliases: I<arithmetic_derivative>

=cut

=head2 digit

    Number.digit()

Return the

=cut

=head2 digits

    Number.digits()

Return the

=cut

=head2 digits2num

    base.digits2num(digits...)

Convert a list of digits to a number in the self base.

The method is implemented as `base.digits2num(digits...)`, where digits are in reverse order.

Example:

    say 10.digits2num(4,3,2,1)  #=> 1234

Aliases: I<from_digits>

=cut

=head2 digits_sum

    Number.digits_sum()

Return the

Aliases: I<sum_digits>, I<sumdigits>

=cut

=head2 dirichlet_sum

    n.dirichlet_sum(f, g, F, G)

The method computes the following sum in O(sqrt(n)) steps:

    Sum_{k=1..n} Sum_{d|k} f(d) * g(k/d)

Where `F` and `G` are the partial sums of `f` and `g`, respectively.

Example:

    say dirichlet_hyperbola(1e3,
            { .is_squarefree ? 1 : 0 },
            { _*_ },
            { .squarefree_count },
            { .faulhaber(2) }
    )

Aliases: I<dirichlet_hyperbola>

=cut

=head2 divides

    Number.divides()

Return the

=cut

=head2 divisor_map

    Number.divisor_map()

Return the

=cut

=head2 divisor_prod

    Number.divisor_prod()

Return the

Aliases: I<divisors_prod>

=cut

=head2 divisors

    Number.divisors()

Return the

=cut

=head2 divisor_sum

    Number.divisor_sum()

Return the

Aliases: I<divisors_sum>

=cut

=head2 divmod

    divmod(a, b)
    divmod(a, b, m)

Returns C<(a/b) % m>.

Example:

    say divmod(43, 97, 127)     # == (43 * invmod(97, 127))%127

When only two arguments are provided, it returns C<(a//b, a%b)>.

Example:

    say [divmod(23, 10)]    #=> [2,3]

=cut

=head2 downto

    Number.downto()

Return the

=cut

=head2 dump

    Number.dump()

Return the

=cut

=head2 e

    Number.e()

Return the

=cut

=head2 each_almost_prime

k.each_almost_prime(n, {...})
k.each_almost_prime(a,b, {...})

Iterates over the k-almost prime numbers <= n, or in the range a..b.

Example:

    11.almost_primes_each(1e7, {|n| say n })        # iterate over 11-almost primes <= 1e6
    11.almost_primes_each(1e6, 1e7, {|n| say n })   # iterate over 11-almost primes in the range [1e6, 1e7]

Aliases: I<almost_primes_each>

=cut

=head2 each_powerful

    Number.each_powerful()

Return the

Aliases: I<powerful_each>

=cut

=head2 each_prime

    n.each_prime {...}
    each_prime(a,b,{...})

It efficiently iterates over the primes in the given range, using a segmented prime sieve.

Example:

    # Iterate over the primes between 100 and 200
    each_prime(100, 200, {|p|
        say p
    })

    # Iterate over the primes <= 100
    100.each_prime {|p|
        say p
    }

It's consirably faster than using the `next_prime(n)` method.

Aliases: I<primes_each>

=cut

=head2 each_semiprime

    Number.each_semiprime()

Return the

Aliases: I<semiprimes_each>

=cut

=head2 each_squarefree

    n.each_squarefree {...}
    each_squarefree(a,b,{...})

Iterates over the squarefree numbers in a given range.

Example:

    # Iterate over the squarefree numbers in the interval [100, 200]
    each_squarefree(100, 200, {|n|
        say n
    })

    # Iterate over the squarefree numbers <= 100
    100.each_squarefree {|n|
        say n
    }

Aliases: I<squarefree_each>

=cut

=head2 each_squarefree_almost_prime

k.each_squarefree_almost_prime(n, {...})
k.each_squarefree_almost_prime(a,b,{...})

Iterates over the squarefree k-almost primes <= n, or in the range a..b.

Example:

    # Iterate over squarefree 3-almost primes <= 100
    3.squarefree_almost_primes_each(100, { .say })

    # Iterate over squarefree 3-almost primes in the range 50..100
    3.squarefree_almost_primes_each(50, 100, { . say })

Aliases: I<squarefree_almost_primes_each>

=cut

=head2 ecm_factor

    n.ecm_factor()
    n.ecm_factor(B)
    n.ecm_factor(B,reps)

Hendrik Lenstra's elliptic curve factorization method (ECM).

=cut

=head2 ei

    Number.ei()

Return the

Aliases: I<eint>

=cut

=head2 erf

    Number.erf()

Return the

=cut

=head2 erfc

    Number.erfc()

Return the

=cut

=head2 euler

    Number.euler()

Return the

Aliases: I<euler_number>

=cut

=head2 euler_polynomial

    Number.euler_polynomial()

Return the

=cut

=head2 exp

    Number.exp()

Return the

=cut

=head2 exp10

    Number.exp10()

Return the

=cut

=head2 exp2

    Number.exp2()

Return the

=cut

=head2 exp_mangoldt

    Number.exp_mangoldt()

Return the

=cut

=head2 expmod

    Number.expmod()

Return the

Aliases: I<powmod>

=cut

=head2 expnorm

    Number.expnorm()

Return the

=cut

=head2 factor

    Number.factor()

Return the

Aliases: I<factors>

=cut

=head2 factor_exp

    Number.factor_exp()

Return the

Aliases: I<factors_exp>

=cut

=head2 factorialmod

    Number.factorialmod()

Return the

=cut

=head2 factorial_power

    Number.factorial_power()

Return the

Aliases: I<factorial_valuation>

=cut

=head2 factorial_sum

    n.factorial_sum()

Left factorial of `n`.

Aliases: I<left_factorial>

=cut

=head2 factor_map

    Number.factor_map()

Return the

=cut

=head2 factor_prod

    Number.factor_prod()

Return the

Aliases: I<factors_prod>

=cut

=head2 factor_sum

    Number.factor_sum()

Return the

Aliases: I<factors_sum>

=cut

=head2 falling_factorial

    Number.falling_factorial()

Return the

=cut

=head2 faulhaber

    Number.faulhaber()

Return the

Aliases: I<faulhaber_sum>

=cut

=head2 faulhaber_polynomial

    faulhaber_polynomial(n,x)

Computes the n-th Faulhaber polynomials evaluated on x.

Defined in terms of the Bernoulli polynomials, as:

    faulhaber_polynomial(n,x) = (bernoulli_polynomial(n+1,x+1) - bernoulli_polynomial(n+1, 1))/(n+1)

=cut

=head2 fermat_factor

    n.fermat_factor(k=1e4)

Tries to factorize a given number using Fermat's factorization method (using at most `k` iterations).

Works for odd composite non-power numbers `n` that have two divisors close to `sqrt(n)`.

=cut

=head2 fib

    Number.fib()

Return the

Aliases: I<fibonacci>

=cut

=head2 fibmod

    Number.fibmod()

Return the

Aliases: I<fibonacci_mod>, I<fibonaccimod>

=cut

=head2 flip

    n.flip(base=10)

Returns the reversal of `n` in base `b`. When `b` is not given, it defaults to base 10.

Example:

    say 20.of { .flip }         # A004086
    say 20.of { .flip(2) }      # A030101

Aliases: I<reverse>

=cut

=head2 flipbit

    Number.flipbit()

Return the

=cut

=head2 floor

    Number.floor()

Return the

=cut

=head2 flt_factor

    n.flt_factor(base=2, tries=1e4)

Tries to find a factor of `n`, using a new factorization method, inspired by Fermat's Little Theorem (FLT).

The method is particularily effective for numbers that have factors closed to each other, or have a factor `k` for which `znorder(2,k)` is small.

Example (try with base 3 and give up after 10^6 iterations):

    say flt_factor(2**64 + 1, 3, 1e6)   #=> [274177, 67280421310721]

=cut

=head2 gcd

    Number.gcd()

Return the

=cut

=head2 gcdext

    Number.gcdext()

Return the

=cut

=head2 geometric_sum

    Number.geometric_sum()

Return the

=cut

=head2 gpf

    n.gpf()

Return the greatest prime factor of n.

Defined with the base-cases:

    gpf(0) = 0
    gpf(1) = 1

Example:

    say gpf(2**128 + 1)     #=> 5704689200685129054721

=cut

=head2 hamdist

    Number.hamdist()

Return the

=cut

=head2 harm

    Number.harm()

Return the

Aliases: I<harmfrac>, I<harmonic>, I<harmonic_number>

=cut

=head2 harmreal

    Number.harmreal()

Return the

=cut

=head2 hermite_H

    Number.hermite_H()

Return the

Aliases: I<hermiteH>, I<hermite_polynomial_H>, I<hermite_polynomialH>

=cut

=head2 hermite_He

    Number.hermite_He()

Return the

Aliases: I<hermiteHe>, I<hermite_polynomial_He>, I<hermite_polynomialHe>

=cut

=head2 holf_factor

    n.holf_factor(reps)

Hart's OLF method (variant of Fermat's method).

=cut

=head2 hyperfactorial

    Number.hyperfactorial()

Return the

=cut

=head2 hyperfactorial_ln

    Number.hyperfactorial_ln()

Return the

Aliases: I<lnhyperfactorial>, I<hyperfactorial_log>

=cut

=head2 hypot

    Number.hypot()

Return the

=cut

=head2 i

    Number.i()

Return the

=cut

=head2 iadd

    Number.iadd()

Return the

=cut

=head2 icbrt

    Number.icbrt()

Return the

=cut

=head2 idiv_ceil

    Number.idiv_ceil()

Return the

=cut

=head2 idiv_trunc

    Number.idiv_trunc()

Return the

=cut

=head2 ilog

    Number.ilog()

Return the

=cut

=head2 ilog10

    Number.ilog10()

Return the

=cut

=head2 ilog2

    Number.ilog2()

Return the

=cut

=head2 im

    Number.im()

Return the

Aliases: I<imag>, I<imaginary>

=cut

=head2 imod

    Number.imod()

Return the

=cut

=head2 imul

    Number.imul()

Return the

=cut

=head2 inf

    Number.inf()

Return the

=cut

=head2 int

    Number.int()

Return the

Aliases: I<to_i>, I<to_int>, I<trunc>

=cut

=head2 inv

    Number.inv()

Return the

=cut

=head2 inverse_phi

    n.inverse_phi()

Returns all the solutions `x` to the Euler totient function: phi(x) = n.

Aliases: I<inverse_totient>

=cut

=head2 inverse_phi_len

    n.inverse_phi_len()

Return the number of solutions to the Euler totient function: phi(x) = n.

Equivalent with:

    n.inverse_phi.len

Aliases: I<inverse_totient_len>

=cut

=head2 inverse_phi_max

    n.inverse_phi_max()

Returns the largest solution x to the Euler totient function: phi(x) = n.

Equivalent with:

    n.inverse_phi.max

Returns C<nil> if there are no solutions.

Aliases: I<inverse_euler_phi_max>

=cut

=head2 inverse_phi_min

    n.inverse_phi_min()

Returns the smallest solution x to the Euler totient function: phi(x) = n.

Equivalent with:

    n.inverse_phi.min

Returns C<nil> if there are no solutions.

Aliases: I<inverse_euler_phi_min>

=cut

=head2 inverse_polygonal

    n.inverse_polygonal()

Returns an array of pairs [r,k] such that `polygonal(r,k) = n`.

Example:

    say polygonal_inverse(4012)   #=> [[2, 4012], [4, 670], [8, 145], [4012, 2]]

Aliases: I<polygonal_inverse>

=cut

=head2 inverse_psi

    n.inverse_psi()

Returns all the solutions `x` to the Dedekin psi function: psi(x) = n.

Example:

    say inverse_psi(120)    #=> [75, 76, 87, 95]

Aliases: I<inverse_dedekind_psi>

=cut

=head2 inverse_psi_len

    n.inverse_psi_len()

Returns the number of solutions to Dedekind's psi function: psi(x) = n.

Equivalent to C<n.inverse_psi.len>, but much faster.

Aliases: I<inverse_dedekind_psi_len>

=cut

=head2 inverse_psi_max

    n.inverse_psi_max()

Returns the largest solution x to the Dedekind psi function: psi(x) = n.

Equivalent with:

    n.inverse_psi.max

Returns C<nil> if there are no solutions.

Aliases: I<inverse_dedekind_psi_max>

=cut

=head2 inverse_psi_min

    n.inverse_psi_min()

Returns the smallest solution x to the Dedekind psi function: psi(x) = n.

Equivalent with:

    n.inverse_psi.min

Returns C<nil> if there are no solutions.

Aliases: I<inverse_dedekind_psi_min>

=cut

=head2 inverse_sigma

    n.inverse_sigma(k=1)

The method returns all the numbers `m` for which `sigma(m,k) = n`, where `n` is given.

Example:

    say inverse_sigma(42)           # [20, 26, 41]
    say inverse_sigma(22100, 2)     # [120, 130, 141]

Also works with arbitrary large integers:

    say inverse_sigma(9325257382230393314439814176)

=cut

=head2 inverse_sigma_len

    n.inverse_sigma_len(k=1)

Returns the number of solutions to the sigma sum of divisors function: sigma_k(x) = n.

Equivalent to `n.inverse_sigma(k).len`, but much faster.

=cut

=head2 inverse_sigma_max

    Number.inverse_sigma_max()

Return the

=cut

=head2 inverse_sigma_min

    Number.inverse_sigma_min()

Return the

=cut

=head2 inverse_uphi

    n.inverse_uphi()

Returns an array with all the solutions `x` to `uphi(x) = n`.

Example:

    say inverse_uphi(120)       #=> [121, 143, 144, 155, 164, 183, 220, 231, 240, 242, 286, 310, 366, 462]

=cut

=head2 inverse_usigma

    n.inverse_usigma()

Returns an array with all the possible solutions for `x` in usigma(x) = n.

Example:

    say inverse_usigma(120)                         #=> [60, 87, 92, 95, 99]
    say inverse_usigma(5040).len                    #=> 38
    say inverse_usigma(5040).map { .usigma }.uniq   #=> [5040]

=cut

=head2 invmod

    n.invmod(m)

Return the modular inverse of n modulo m.

=cut

=head2 ipolygonal_root

    Number.ipolygonal_root()

Return the

=cut

=head2 ipolygonal_root2

    Number.ipolygonal_root2()

Return the

=cut

=head2 ipow

    Number.ipow()

Return the

=cut

=head2 ipow10

    Number.ipow10()

Return the

=cut

=head2 ipow2

    Number.ipow2()

Return the

=cut

=head2 iquadratic_formula

    Number.iquadratic_formula()

Return the

Aliases: I<integer_quadratic_formula>

=cut

=head2 irand

    Number.irand()

Return the

=cut

=head2 iroot

    Number.iroot()

Return the

=cut

=head2 irootrem

    Number.irootrem()

Return the

=cut

=head2 is_abundant

    n.is_abundant()

Returns true when sigma(n) > 2*n.

=cut

=head2 is_aks_prime

    n.is_aks_prime()

Return true if `n` passes the Agrawal-Kayal-Saxena (AKS) primality test.

=cut

=head2 is_almost_prime

    n.is_almost_prime(k)

Return true if `n` is a k-almost prime (i.e.: true iff `n` is the product of `k` not necessarily distinct primes).

Equivalently, k-almost primes are numbers n such that bigomega(n) == k.

Example:

    say 20.by { .is_almost_prime(1) }   # primes
    say 20.by { .is_almost_prime(2) }   # semiprimes
    say 20.by { .is_almost_prime(3) }   # 3-almost primes

=cut

=head2 is_between

    n.is_between(min, max)

Returns a true value when `n >= min` and `n <= max`.

=cut

=head2 is_bpsw_prime

    n.is_bpsw_prime()

Returns true if `n` passes the B-PSW primality test (extra-strong variant).

=cut

=head2 is_carmichael

    n.is_carmichael()

Returns true if is a Carmichael number.

=cut

=head2 is_chebyshev

    n.is_chebyshev()

Returns true if `n` is an odd composite Chebyshev pseudoprime, as defined by OEIS A175530.

Aliases: I<is_chebyshev_psp>, I<is_chebyshev_pseudoprime>

=cut

=head2 is_complex

    Number.is_complex()

Return the

=cut

=head2 is_composite

    n.is_composite()

Returns true if `n` is a positive > 1 composite number.

=cut

=head2 is_congruent

    n.is_congruent(a,m)

Returns true when n is congruent to a modulo m.

Example:

    say 99923.is_congruent(-2, 5)   #=> true
    say 99923.is_congruent(3, 5)    #=> true

Also defined for rationals, floats and complex numbers:

    say is_congruent(124, 1/4, 3/4) #=> true

=cut

=head2 is_coprime

    Number.is_coprime()

Return the

=cut

=head2 is_cube

    n.is_cube()

Return true if n is a cube number (if it can be written as b^3, for some integer b).

=cut

=head2 is_cyclic

    n.is_cyclic()

Returns true when `gcd(phi(n), n) = 1`, where `phi(n)` is the Euler totient function.

Example:

    say 30.by { .is_cyclic }    # OEIS: A003277

=cut

=head2 is_ecpp_prime

    n.is_ecpp_prime()

Return true if `n` can be proved prime using the Elliptic Curve Primality Proving algorithm.

=cut

=head2 iseed

    Number.iseed()

Return the

=cut

=head2 is_euler_psp

    n.is_euler_psp(bases...)

Return true if `n` is an Euler-Jacobi pseudoprime, given a list of bases.

Aliases: I<is_euler_pseudoprime>

=cut

=head2 is_even

    Number.is_even()

Return the

=cut

=head2 is_fib

    n.is_fib()

Returns true if n is a Fibonacci number. False otherwise.

Aliases: I<is_fibonacci>

=cut

=head2 is_fib_psp

    n.is_fib_psp(P=1, Q=-1)

Returns true if `n` passes the Lucas test to the `U`, using the parameters `P` and `Q`.

Example:

    say 10.by { .is_composite && .is_lucasU_psp }               # Fibonacci pseudoprimes
    say 10.by { .is_odd_composite && .is_lucasU_psp(2, -1) }    #=> A327651

Aliases: I<is_lucasu_psp>, I<is_lucasU_psp>, I<is_fibonacci_psp>, I<is_lucasU_pseudoprime>, I<is_fibonacci_pseudoprime>

=cut

=head2 is_frobenius_psp

    n.is_frobenius_psp(a,b)

Return true if `n` is a Frobenius probable prime with respect to the polynomial `x^2 - ax + b`.

Aliases: I<is_frobenius_pseudoprime>

=cut

=head2 is_fundamental

    Number.is_fundamental()

Return the

=cut

=head2 is_gaussian_prime

    is_gaussian_prime(a,b)

Returns true if a+b*i is a Gaussian prime.

Example:

    say is_gaussian_prime(3, 4)       #=> false
    say is_gaussian_prime(13, 42)     #=> true

Provided by L<Math::Prime::Util::GMP> >= 0.52.

=cut

=head2 is_imag

    Number.is_imag()

Return the

=cut

=head2 is_imprimitive_carmichael

    n.is_imprimitive_carmichael()

Returns true if `n` is an imprimitive Carmichael numbers, as defined by OEIS: A328935.

Example:

    say 325533792014488126487416882038879701391121.is_imprimitive_carmichael   # true

The method efficiently tries to factorize large Carmichael numbers, using the `miller_factor(n)` method.

=cut

=head2 is_inf

    Number.is_inf()

Return the

=cut

=head2 is_int

    Number.is_int()

Return the

=cut

=head2 is_khashin_psp

    n.is_khashin_psp()

Return true if `n` passes the Frobenius test of Sergey Khashin.

Aliases: I<is_khashin_pseudoprime>, I<is_frobenius_khashin_psp>, I<is_frobenius_khashin_pseudoprime>

=cut

=head2 is_lucas

    n.is_lucas()

Returns true if n is a Lucas number. False otherwise.

=cut

=head2 is_lucas_carmichael

    n.is_lucas_carmichael()

Returns true if `n` is a Lucas-Carmichael number.

Example:
    say 10.by(:is_lucas_carmichael)                               # OEIS: A006972
    say is_lucas_carmichael(58735331016965175152455996272482303)  # true

=cut

=head2 is_lucas_psp

    n.is_lucas_psp()

Return true if `n` is a Lucas pseudoprime.

Aliases: I<is_lucas_pseudoprime>

=cut

=head2 is_lucasv_psp

    n.is_lucasv_psp(P=1, Q=-1)

Returns true if `n` passes the Lucas test to the `V` sequence, using the paramters `P` and `Q`.

Example:

    say 10.by { .is_composite && .is_lucasV_psp }               # Bruckman-Lucas pseudoprimes
    say 10.by { .is_odd_composite && .is_lucasV_psp(2, -1) }    #=> A330276

Aliases: I<is_lucasV_psp>, I<is_bruckman_lucas_psp>, I<is_lucasV_pseudoprime>, I<is_bruckman_lucas_pseudoprime>

=cut

=head2 is_mersenne_prime

    Number.is_mersenne_prime()

Return the

=cut

=head2 is_mone

    Number.is_mone()

Return the

=cut

=head2 is_nan

    Number.is_nan()

Return the

=cut

=head2 is_neg

    Number.is_neg()

Return the

Aliases: I<is_negative>

=cut

=head2 is_ninf

    Number.is_ninf()

Return the

=cut

=head2 is_nm1_prime

    n.is_nm1_prime()

Return true if `n` can be proved prime using the factorization of `n-1`.

Aliases: I<is_pm1_prime>, I<is_nminus1_prime>

=cut

=head2 is_np1_prime

    n.is_np1_prime()

Return true if `n` can be proved prime using the factorization of `n+1`.

Aliases: I<is_pp1_prime>, I<is_nplus1_prime>

=cut

=head2 is_odd

    Number.is_odd()

Return the

=cut

=head2 is_odd_composite

    Number.is_odd_composite()

Return the

=cut

=head2 is_one

    Number.is_one()

Return the

=cut

=head2 is_over_psp

    n.is_over_psp()

Returns true if `n` is an overpseudoprime to base `b`. Multiple bases can also be provided.

An overpseudoprime to base `b` is a also a strong Fermat pseudoprime to base `b` and a super-pseudoprime to base `b`, where znorder(b,n) == znorder(b,p) for every p|n.

Example:

    say 10.by { .is_composite && .is_over_psp }         # overpseudoprimes to base 2
    say 10.by { .is_composite && .is_over_psp(3) }      # overpseudoprimes to base 3

Aliases: I<is_over_pseudoprime>, I<is_overpseudoprime>

=cut

=head2 is_palindrome

    n.is_palindrome()

Returns true if the given number `n` is palindromic in the given base `b`. When no base is given, it defaults to 10.

Example:

    # Numbers that are palindromic in bases 2 and 10 (OEIS: A007632)
    say 1e6.range.grep{ .is_palindrome(2) && .is_palindrome(10) }

Aliases: I<is_palindromic>

=cut

=head2 is_pell_lucas_psp

    n.is_pell_lucas_psp()

It returns true if `V_n(2, -1) = 2 (mod n)`.

Example:

    say 20.by { .is_pell_lucas_pseudoprime }                                 #=> A270342
    say 20.by { .is_pell_lucas_pseudoprime && .is_composite }                #=> A335668
    say 20.by { .is_pell_lucas_pseudoprime && .is_composite && .is_odd }     #=> A330276

Aliases: I<is_pell_lucas_pseudoprime>

=cut

=head2 is_pell_psp

    n.is_pell_psp()

These are odd numbers that satisfy:

    U_n(2, -1) = (2|n) (mod n)

Example:

    say 10.by { .is_pell_pseudoprime && .is_composite }  # OEIS: A099011

Aliases: I<is_pell_pseudoprime>

=cut

=head2 is_perrin_psp

    Number.is_perrin_psp()

Return the

Aliases: I<is_perrin_pseudoprime>

=cut

=head2 is_plumb_psp

    n.is_plumb_psp()

Return true if `n` passes Colin Plumb's Euler Criterion primality test.

Aliases: I<is_euler_plumb_psp>, I<is_plumb_pseudoprime>, I<is_euler_plumb_pseudoprime>

=cut

=head2 is_polygonal

    Number.is_polygonal()

Return the

=cut

=head2 is_polygonal2

    Number.is_polygonal2()

Return the

=cut

=head2 is_pos

    Number.is_pos()

Return the

Aliases: I<is_positive>

=cut

=head2 is_pow

    Number.is_pow()

Return the

Aliases: I<is_power>, I<is_perfect_power>

=cut

=head2 is_powerful

    n.is_powerful(k=2)

Returns true when all the exponents in the prime-power factorization of n are >= k.

=cut

=head2 is_power_of

    n.is_power_of(b)

Return true if n is a power of b, such that n = b^k for some k >= 0:

    n.is_power_of(b)    # true if n == b^k for some k >= 0

Example:

    say 1000.range.grep { .is_power_of(2) }     # powers of 2
    say 1000.range.grep { .is_power_of(5) }     # powers of 5

=cut

=head2 is_practical

    n.is_practical()

Returns true if n is a practical number (OEIS: A005153).

Example:

    say 20.by { .is_practical }

=cut

=head2 is_prime

    Number.is_prime()

Return the

=cut

=head2 is_prime_power

    Number.is_prime_power()

Return the

=cut

=head2 is_primitive_root

    Number.is_primitive_root()

Return the

=cut

=head2 is_prob_prime

    Number.is_prob_prime()

Return the

=cut

=head2 is_prob_squarefree

    n.is_prob_squarefree(k)

Returns true iff `n` is not a power and is not divisible by a square <= k.

=cut

=head2 is_prov_prime

    Number.is_prov_prime()

Return the

Aliases: I<is_provable_prime>

=cut

=head2 is_psp

    n.is_psp(bases...)

Returns true if `n` is a Fermat pseudoprime to the provided bases.

Aliases: I<is_fermat_psp>, I<is_pseudoprime>, I<is_fermat_pseudoprime>

=cut

=head2 isqrt

    Number.isqrt()

Return the

=cut

=head2 isqrtrem

    Number.isqrtrem()

Return the

=cut

=head2 is_rat

    Number.is_rat()

Return the

=cut

=head2 is_real

    Number.is_real()

Return the

=cut

=head2 is_rough

    n.is_rough(k)

Returns true if all prime factors of n are >= k.

Example:

    say 30.by { .is_rough(3) }  #=> A005408
    say 30.by { .is_rough(5) }  #=> A007310
    say 30.by { .is_rough(7) }  #=> A007775
    # ...
    say 30.by { .is_rough(23) } #=> A166063

=cut

=head2 is_safe_prime

    n.is_safe_prime()

It returns true if both `n` and `(n-1)/2` are prime.

Example:

    say 30.by { .is_safe_prime }    #=> A005385

=cut

=head2 is_semiprime

    Number.is_semiprime()

Return the

=cut

=head2 is_smooth

    n.is_smooth(k)

Returns true if n is k-smooth.

=cut

=head2 is_smooth_over_prod

    n.is_smooth_over_prod(k)

Returns true when `n` is smooth over the prime factors of `k`.

=cut

=head2 is_sqr

    Number.is_sqr()

Return the

Aliases: I<is_square>, I<is_perfect_square>

=cut

=head2 is_square_free

    Number.is_square_free()

Return the

Aliases: I<is_squarefree>

=cut

=head2 is_stronger_lucas_psp

    n.is_stronger_lucas_psp()

Return true if `n` is an extra-strong Lucas pseudoprime.

Aliases: I<is_extra_strong_lucas_psp>, I<is_stronger_lucas_pseudoprime>, I<is_extra_strong_lucas_pseudoprime>

=cut

=head2 is_strong_fib

    n.is_strong_fib()

Teturns true if `n` is a strong Fibonacci pseudoprime, satisfying:

    V_n(P,Q) = P (mod)

for Q = -1 and all P.

Odd composite integer n is a strong Fibonacci pseudoprime iff:

    1) n is a Carmichael number: p-1 | n-1
    2) 2(p + 1) | (n − 1) or 2(p + 1) | (n − p)

for each prime p|n.

Example:

    say is_strong_fibonacci_pseudoprime(443372888629441)    #=> true
    say is_strong_fibonacci_pseudoprime(39671149333495681)  #=> true

Aliases: I<is_strong_fib_psp>, I<is_strong_fibonacci>, I<is_strong_fibonacci_psp>, I<is_strong_fibonacci_pseudoprime>

=cut

=head2 is_strongish_lucas_psp

    n.is_strongish_lucas_psp()

Return true if `n` is almost an extra-strong Lucas pseudoprime.

Aliases: I<is_strongish_lucas_pseudoprime>

=cut

=head2 is_strong_lucas_psp

    n.is_strong_lucas_psp()

Return true if `n` is a strong Lucas pseudoprime.

Aliases: I<is_strong_lucas_pseudoprime>

=cut

=head2 is_strong_psp

    n.is_strong_psp(bases...)

Return true if `n` is a strong pseudoprime.

Aliases: I<miller_rabin>, I<is_strong_fermat_psp>, I<is_strong_pseudoprime>, I<is_strong_fermat_pseudoprime>

=cut

=head2 is_super_psp

    n.is_super_psp(bases...)

It returns true if the given value of n is a super-pseudoprime to the given bases. When no base is given, the base 2 is used (which represents the Super-Poulet numbers: A050217)

Example:

    # Super-Poulet numbers (OEIS: A050217)
    say 1e4.range.grep { .is_super_pseudoprime }.grep{ .is_composite }

    # Super-Poulet numbers to base 3 (OEIS: A328662)
    say 1e4.range.grep { .is_super_pseudoprime(3) }.grep{ .is_composite }

    # Super-Poulet numbers to base 2 and 3
    say 1e5.range.grep { .is_super_pseudoprime(2, 3) }.grep{ .is_composite }

Aliases: I<is_super_pseudoprime>, I<is_superpseudoprime>

=cut

=head2 is_totient

    Number.is_totient()

Return the

=cut

=head2 isub

    Number.isub()

Return the

=cut

=head2 is_underwood_psp

    n.is_underwood_psp()

Return true if `n` passes the efficient Frobenius test of Paul Underwood.

Aliases: I<is_underwood_pseudoprime>, I<is_frobenius_underwood_psp>, I<is_frobenius_underwood_pseudoprime>

=cut

=head2 is_zero

    Number.is_zero()

Return the

=cut

=head2 jacobi

    Number.jacobi()

Return the

=cut

=head2 jordan_totient

    Number.jordan_totient()

Return the

=cut

=head2 kronecker

    Number.kronecker()

Return the

=cut

=head2 laguerre

    Number.laguerre()

Return the

Aliases: I<laguerreL>, I<laguerre_polynomial>

=cut

=head2 lambda

    lambda(n)

Carmichael lambda function: C<λ(n)>, defined as the smallest positive integer C<m> such that:

    aᵐ ≡ 1 (mod n)

for every integer C<a> between C<1> and C<n> that is coprime to C<n>.

Alias: I<carmichael_lambda>.

=cut

=head2 lambert_w

    Number.lambert_w()

Return the

=cut

=head2 lcm

    Number.lcm()

Return the

=cut

=head2 legendre

    Number.legendre()

Return the

=cut

=head2 legendre_P

    Number.legendre_P()

Return the

Aliases: I<legendrep>, I<legendreP>, I<legendre_polynomial>

=cut

=head2 legendre_phi

    n.legendre_phi(k)

Returns the count of numbers <= `n` that are not divisible by the first `k` primes.

Equivalent with:

    rough_count(n, prime(k+1))

=cut

=head2 len

    Number.len()

Return the

Aliases: I<size>, I<length>

=cut

=head2 lgamma

    Number.lgamma()

Return the

Aliases: I<gamma_abs_log>

=cut

=head2 lgrt

    Number.lgrt()

Return the

=cut

=head2 li

    Number.li()

Return the

=cut

=head2 li2

    Number.li2()

Return the

=cut

=head2 liouville

    Number.liouville()

Return the

=cut

=head2 liouville_sum

    n.liouville_sum()

Computes partial sums of the Liouville lambda function.

Example:

    say liouville_sum(10**9)    #=> -25216
    say liouville_sum(10**10)   #=> -116026

=cut

=head2 ln

    Number.ln()

Return the

=cut

=head2 ln2

    Number.ln2()

Return the

=cut

=head2 lnbern

    Number.lnbern()

Return the

Aliases: I<bern_log>, I<lnbernreal>, I<bernoulli_log>

=cut

=head2 lngamma

    Number.lngamma()

Return the

Aliases: I<gamma_log>

=cut

=head2 lnsuperfactorial

    Number.lnsuperfactorial()

Return the

Aliases: I<superfactorial_ln>, I<superfactorial_log>

=cut

=head2 log

    Number.log()

Return the

=cut

=head2 log10

    Number.log10()

Return the

=cut

=head2 log2

    Number.log2()

Return the

=cut

=head2 logarithmic_derivative

    Number.logarithmic_derivative()

Return the

=cut

=head2 lpf

    n.lpf()

Returns the least prime factor of n.

Defined with the base-cases:

    lpf(0) = 0
    lpf(1) = 1

Example:

    say lpf(fibonacci(1234))    #=> 234461

=cut

=head2 lsb

    Number.lsb()

Return the

=cut

=head2 lucas

    Number.lucas()

Return the

=cut

=head2 lucas_factor

    n.lucas_factor(j=1, tries=100)

Effective in factoring Carmichael numbers, Fermat pseudoprimes, Lucas pseudoprimes and Lucas-Carmichael numbers.

Example:

    say lucas_factor(2425361208749736840354501506901183117777758034612345610725789878400467)

Aliases: I<lucas_miller_factor>

=cut

=head2 lucas_mod

    Number.lucas_mod()

Return the

Aliases: I<lucasmod>

=cut

=head2 lucas_U

    Number.lucas_U()

Return the

Aliases: I<lucasu>, I<lucasU>

=cut

=head2 lucasumod

lucasumod(P,Q,n,m) -> I<Number>

Lucas U_n(P,Q) (mod m) function.

Aliases: I<lucasUmod>

=cut

=head2 lucasuvmod

    Number.lucasuvmod()

Return the

Aliases: I<lucasUVmod>

=cut

=head2 lucas_V

    Number.lucas_V()

Return the

Aliases: I<lucasv>, I<lucasV>

=cut

=head2 lucasvmod

lucasvmod(P,Q,n,m)

Lucas V_n(P,Q) (mod m) function.

Aliases: I<lucasVmod>

=cut

=head2 make_coprime

    Number.make_coprime()

Return the

=cut

=head2 mangoldt

    Number.mangoldt()

Return the

=cut

=head2 max

    Number.max()

Return the

=cut

=head2 mertens

mertens(n)
mertens(a,b)

Return the Mertens functions, which is defined as the partial sums of the Moebius function:

    Sum_{k=1..n} moebius(k)

When an additional argument is given, the returned result is:

    Sum_{k=a..b} moebius(k)

Example:

    say mertens(100000)     # equilvanet with: (1..100000 -> sum { .moebius })
    say mertens(21, 123)    # equivalent with: (21..123 -> sum { .moebius })

=cut

=head2 mfac

    Number.mfac()

Return the

Aliases: I<mfactorial>, I<multi_factorial>

=cut

=head2 miller_factor

    n.miller_factor(tries=100)

Effective in factoring Carmichael numbers and Fermat pseudoprimes.

It returns an array with the factors of `n`. However, sometimes, not all factors are prime.

Example:

    say miller_factor(58571442634534443082821160508299574798027946748324125518533225605795841)

Aliases: I<miller_rabin_factor>

=cut

=head2 miller_rabin_random

    n.miller_rabin_random(k)

Return true if `n` passes the Miller-Rabin primality test with `k` random bases.

=cut

=head2 min

    Number.min()

Return the

=cut

=head2 mone

    Number.mone()

Return the

=cut

=head2 motzkin

    n.motzkin()

Return the n-th Motzkin number. (OEIS: A001006)

Example:

    say 10.of { .motzkin }   #=> [1, 1, 2, 4, 9, 21, 51, 127, 323, 835]

=cut

=head2 msb

    Number.msb()

Return the

=cut

=head2 mulmod

    mulmod(a,b,m)

Returns C<(a*b) % m>.

Example:

    say mulmod(43, 97, 127)     # == (43*97)%127

=cut

=head2 multinomial

    Number.multinomial()

Return the

=cut

=head2 nan

    Number.nan()

Return the

=cut

=head2 n_composites

    n_composites(n, start=4)

Returns n consecutive composite numbers starting from `start`.

Example:

    say n_composites(10)        #=> [4, 6, 8, 9, 10, 12, 14, 15, 16, 18]
    say n_composites(5, 50)     #=> [50, 51, 52, 54, 55]

Aliases: I<ncomposites>

=cut

=head2 nd

    n.st({...})
    n.nd({...})
    n.rd({...})
    n.th({...})

It returns the n-th value for which the provided block evaluates to a true value, starting couting from 0.

Example:

    say 100.th { .is_prime }    # 100-th prime

Also aliased as `.st`, `.nd` and `.rd`:

    say 1.st { .is_prime }      # first prime
    say 2.nd { .is_prime }      # second prime
    say 3.rd { .is_prime }      # third prime

Aliases: I<rd>, I<st>, I<th>

=cut

=head2 neg

    Number.neg()

Return the

=cut

=head2 new

    Number.new()

Return the

Aliases: I<call>

=cut

=head2 next_composite

    n.next_composite()

Given a non-negative integer `n`, it returns the next composite number after `n`.

=cut

=head2 next_palindrome

    n.next_palindrome(b=10)

Efficiently returns the next palindrome in base-b greater than n.

Example:

    # Iterate over the base-10 palindromic numbers < 10^6
    for (var n = 0; n < 1e6; n = n.next_palindrome) {
        say n
    }

=cut

=head2 next_pow

    Number.next_pow()

Return the

Aliases: I<next_power>

=cut

=head2 next_pow2

    Number.next_pow2()

Return the

Aliases: I<next_power2>

=cut

=head2 next_prime

    Number.next_prime()

Return the

=cut

=head2 next_twin_prime

    n.next_twin_prime()

Returns next twin prime number larger than n.

Provided by L<Math::Prime::Util::GMP> >= 0.52.

=cut

=head2 ninf

    Number.ninf()

Return the

=cut

=head2 nok

    Number.nok()

Return the

Aliases: I<binomial>

=cut

=head2 norm

    Number.norm()

Return the

=cut

=head2 n_primes

    n_primes(n, start=2)

It returns an array containing `n` consecutive primes that are `>= start` (if omitted, then start = 2).

Example:

    say n_primes(10)        #=> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    say n_primes(10, 1000)  #=> [1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061]

The value for `start` can be any arbitary large integer:

    say n_primes(10, 2**128 + 1)    # first 10 primes > 2^128

Aliases: I<nprimes>

=cut

=head2 nu

    Number.nu()

Return the

Aliases: I<numerator>

=cut

=head2 nude

    Number.nude()

Return the

=cut

=head2 num2perm

    Number.num2perm()

Return the

=cut

=head2 numify

    n.numify()

Returns a raw native number representation for the self-number.

Can be used for assigning values to `Num!PREC` variable.

Example:

    local Num!PREC = 42.numify  # set precision to 42 bits
    say sqrt(2)                 # 1.414213562

Native numbers can also be used when indexing an array:

    var arr = [42, 43, 44]
    var idx = 2.numify
    say arr[idx]            #=> 44

Although this may or may not be actually faster.

=cut

=head2 of

    Number.of()

Return the

=cut

=head2 one

    Number.one()

Return the

=cut

=head2 partitions

    Number.partitions()

Return the

Aliases: I<partition_number>

=cut

=head2 parts

    Number.parts()

Return the

=cut

=head2 pbrent_factor

    n.pbrent_factor(reps)

Pollard-Brent rho factorization method.

=cut

=head2 perfect_power

    Number.perfect_power()

Return the

=cut

=head2 perfect_root

    Number.perfect_root()

Return the

=cut

=head2 permutations

    Number.permutations()

Return the

=cut

=head2 pi_k

    Number.pi_k()

Return the

Aliases: I<k_prime_count>, I<almost_primepi>, I<almost_prime_count>

=cut

=head2 pm1_factor

    n.pm1_factor(B)

Pollard p-1 factorization method.

Aliases: I<pminus1_factor>

=cut

=head2 pn_primes

    pn_primes(n)
    pn_primes(a,b)

Returns the first n prime numbers, or the primes in the range prime(a)..prime(b).

Example:

    say pn_primes(25)        # the first 25 primes
    say pn_primes(100, 110)  # the primes from 100-th prime to 110-th prime (inclusive)

=cut

=head2 pn_primorial

    Number.pn_primorial()

Return the

=cut

=head2 polygonal

    Number.polygonal()

Return the

=cut

=head2 polygonal_root

    Number.polygonal_root()

Return the

=cut

=head2 polygonal_root2

    Number.polygonal_root2()

Return the

=cut

=head2 polymod

    Number.polymod()

Return the

=cut

=head2 popcount

    Number.popcount()

Return the

Aliases: I<hammingweight>

=cut

=head2 power_count

    n.power_count()

Returns the number of perfect powers <= n.

Example:

    say power_count(10**6)      #=> 1111
    say power_count(10**20)     #=> 10004650118

Aliases: I<perfect_power_count>

=cut

=head2 powerful

k.powerful(n)
k.powerful(a,b)

It efficiently generates all the k-powerful numbers <= n, or in the range a..b.

Example:

    say 2.powerful(100)          #=> 2-powerful numbers <= 100
    say 2.powerful(50, 100)      #=> 2-powerful numbers in the range 50..100

=cut

=head2 powerful_count

k.powerful_count(n)
k.powerful_count(a,b)

It efficiently counts the number of k-powerful numbers <= n, or in the range a..b;

    say 2.powerful_count(100)       #=> number of 2-powerful numbers <= 100
    say 2.powerful_count(50, 100)   #=> number of 2-powerful numbers in the range 50..100

=cut

=head2 pp1_factor

    n.pp1_factor(B)

Williams' p+1 factorization method.

Aliases: I<pplus1_factor>

=cut

=head2 prev_prime

    Number.prev_prime()

Return the

=cut

=head2 prho_factor

    n.prho_factor(reps)

Pollard rho factorization method.

=cut

=head2 primality_pretest

    n.primality_pretest()

The method returns true when `n` passes the internal primality pretest (when n is large enough and it has no small factors).

=cut

=head2 prime

    Number.prime()

Return the

Aliases: I<nth_prime>

=cut

=head2 prime_divisors

    n.prime_divisors()

Returns the unique prime factors of `n`.

=cut

=head2 primepi

    Number.primepi()

Return the

Aliases: I<prime_count>, I<count_primes>

=cut

=head2 primepi_lower

    n.primepi_lower()

Lower bound for prime_count(n).

Aliases: I<prime_count_lower>

=cut

=head2 primepi_upper

    n.primepi_upper()

Upper bound for prime_count(n).

Aliases: I<prime_count_upper>

=cut

=head2 prime_power

    Number.prime_power()

Return the

=cut

=head2 prime_power_count

prime_power_count(n)
prime_power_count(a,b)

Returns the number of prime powers <= n, or in the range a..b.

Example:

    say prime_power_count(1e15)     # number of prime powers <= 10^15
    say prime_power_count(1e6, 1e8) # number of prime powers in [10^6, 10^8]

=cut

=head2 prime_power_divisors

    n.prime_power_divisors()

Return the prime power divisors of n.

Example:

    say prime_power_divisors(5040)  #=> [2, 3, 4, 5, 7, 8, 9, 16]

Equivalent with:

    n.divisors.grep{.is_prime_power}

=cut

=head2 prime_power_sigma

    Number.prime_power_sigma()

Return the

=cut

=head2 prime_power_udivisors

    n.prime_power_udivisors()

Return the unitary prime power divisors of n.

Example:

    say prime_power_udivisors(10!)  #=> [7, 25, 81, 256]

The product of the unitary prime power divisors of a number, is the number itself.

This method is equivalent with:

    n.factor_map {|p,k| p**k }.sort

Aliases: I<prime_power_unitary_divisors>, I<unitary_prime_power_divisors>

=cut

=head2 prime_power_usigma

    Number.prime_power_usigma()

Return the

=cut

=head2 prime_root

    Number.prime_root()

Return the

=cut

=head2 primes

    Number.primes()

Return the

=cut

=head2 prime_sigma

    Number.prime_sigma()

Return the

=cut

=head2 prime_sum

    Number.prime_sum()

Return the

Aliases: I<primes_sum>, I<sum_primes>

=cut

=head2 prime_udivisors

    n.prime_udivisors()

Returns the unique unitary prime factors of `n`.

Aliases: I<prime_unitary_divisors>, I<unitary_prime_divisors>

=cut

=head2 prime_usigma

    Number.prime_usigma()

Return the

=cut

=head2 prime_usigma0

    Number.prime_usigma0()

Return the

=cut

=head2 primitive_part

    n.primitive_part(f)

Returns the primitive part of `f(n)`, for n > 0, such that:

    a(n) = primitive part of f(n)
    f(n) = Product_{d|n} a(d)

Example:

    func f(n) { n.fib }
    func a(n) { n.primitive_part(f) }

    say 20.of { a(_) }
    say 20.of { f(_) }
    say 20.of { .divisors.prod {|d| a(d) } }

=cut

=head2 primorial

    Number.primorial()

Return the

=cut

=head2 primorial_deflation

    n.primorial_deflation()

Primorial deflation of n, satisfying:

    primorial_inflation(primorial_deflation(n)) = n

Defined as:

    primorial_deflation(n) = A319626(n)/A319627(n)

=cut

=head2 primorial_inflation

    n.primorial_inflation()

Primorial inflation of n: fully multiplicative with a(p) = primorial(p).

Defined as:

    primorial_inflation(n) = A108951(n)

The  method also accepts `n` to be a fraction, which is computed as:

    primorial_inflation(a/b) = primorial_inflation(a)/primorial_inflation(b)

=cut

=head2 psi

    n.psi(k=1)

Dedekind psi function.

Example:

    say 10.of { .dedekind_psi    }   #=> [0, 1, 3, 4, 6, 6, 12, 8, 12, 12]
    say 10.of { .dedekind_psi(2) }   #=> [0, 1, 5, 10, 20, 26, 50, 50, 80, 90]

Aliases: I<dedekind_psi>

=cut

=head2 qnr

    n.qnr()

Returns the least quadratic non-residue of n.

Example:

    say qnr(17676352761153241)      #=> 37
    say qnr(172138573277896681)     #=> 41

Aliases: I<quadratic_nonresidue>

=cut

=head2 qs_factor

    n.qs_factor()

Pomerance's Quadratic Sieve factorization method (SIMPQS).

=cut

=head2 quadratic_formula

    Number.quadratic_formula()

Return the

=cut

=head2 rad

    Number.rad()

Return the

=cut

=head2 rad2deg

    Number.rad2deg()

Return the

=cut

=head2 ramanujan_sum

    Number.ramanujan_sum()

Return the

=cut

=head2 ramanujan_tau

    Number.ramanujan_tau()

Return the

=cut

=head2 rand

    Number.rand()

Return the

=cut

=head2 random_bytes

    Number.random_bytes()

Return the

=cut

=head2 random_maurer_nbit_prime

    n.random_maurer_nbit_prime()

Generate a random k-bit Marurer prime.

Aliases: I<random_nbit_maurer_prime>

=cut

=head2 random_nbit_prime

    Number.random_nbit_prime()

Return the

=cut

=head2 random_nbit_strong_prime

    n.random_nbit_strong_prime()

Generate a random k-bit strong prime number.

Aliases: I<random_strong_nbit_prime>

=cut

=head2 random_ndigit_prime

    Number.random_ndigit_prime()

Return the

=cut

=head2 random_prime

    Number.random_prime()

Return the

=cut

=head2 random_safe_prime

    n.random_safe_prime()

Returns a random n-bit safe-prime.

Example:

    say random_safe_prime(512)   #=> 512-bit prime

Provided by L<Math::Prime::Util::GMP> >= 0.52.

=cut

=head2 random_string

    Number.random_string()

Return the

=cut

=head2 range

    Number.range()

Return the

=cut

=head2 rat

    Number.rat()

Return the

Aliases: I<to_r>, I<to_rat>

=cut

=head2 rat_approx

    Number.rat_approx()

Return the

=cut

=head2 re

    Number.re()

Return the

Aliases: I<real>

=cut

=head2 reals

    Number.reals()

Return the

=cut

=head2 remdiv

    Number.remdiv()

Return the

Aliases: I<remove>

=cut

=head2 rising_factorial

    Number.rising_factorial()

Return the

=cut

=head2 root

    Number.root()

Return the

=cut

=head2 rough_count

    n.rough_count()

It efficiently counts the number of k-rough <= n.

Example:

    say rough_count(1e6, 97)    #=> 122005
    say rough_count(1e9, 23)    #=> 171024023

Also works with arbitarily large n:

    say rough_count(1e34, 43)   #=> 1450936704022016442012254601096989

=cut

=head2 rough_part

    n.rough_part(k)

It returns the k-rough part of n that contains all the prime factors p|n such that p >= k.

Example:

    say 15.of {|n| rough_part(n!, 3) }      #=> OEIS: A049606

=cut

=head2 round

    Number.round()

Return the

Aliases: I<roundf>

=cut

=head2 run

    Number.run()

Return the

=cut

=head2 sec

    Number.sec()

Return the

=cut

=head2 secant_number

    Number.secant_number()

Return the

=cut

=head2 sech

    Number.sech()

Return the

=cut

=head2 seed

    Number.seed()

Return the

=cut

=head2 semiprime

    n.semiprime()

Returns the n-th semiprime number.

Example:

    say 10.of {|k| nth_semiprime(10**k) }

Aliases: I<nth_semiprime>

=cut

=head2 semiprime_count

    semiprime_count(n)
    semiprime_count(a,b)

Counts the number of semiprimes <= n (OEIS: A072000), or in the range a..b.

Example:

    say 20.of {|k| semiprime_count(2**k) }

=cut

=head2 semiprimes

    Number.semiprimes()

Return the

=cut

=head2 setbit

    Number.setbit()

Return the

=cut

=head2 sgn

    Number.sgn()

Return the

Aliases: I<sign>

=cut

=head2 sigma0

    Number.sigma0()

Return the

=cut

=head2 sin

    Number.sin()

Return the

=cut

=head2 sin_cos

    Number.sin_cos()

Return the

=cut

=head2 sinh

    Number.sinh()

Return the

=cut

=head2 smooth_count

    n.smooth_count(k)

Returns the number of k-smooth numbers <= n.

Example:

    say 30.of {|n| smooth_count(10**n, 13) }   #=> A106629

=cut

=head2 smooth_part

    n.smooth_part(k)

It efficiently returns the largest divisor of n that is k-smooth.

Example:

    say 20.of {|n| smooth_part(n!, 3) }     #=> OEIS: A118381

=cut

=head2 solve_pell

    Number.solve_pell()

Return the

=cut

=head2 sopf

    n.sopf()

Returns the sum of the distinct primes dividing n.

Example:

    say 30.of { .sopf } #=> OEIS: A008472

=cut

=head2 sopfr

    Number.sopfr()

Return the

=cut

=head2 sqr

    Number.sqr()

Return the

=cut

=head2 sqrt

    Number.sqrt()

Return the

=cut

=head2 sqrt_cfrac

    Number.sqrt_cfrac()

Return the

=cut

=head2 sqrt_cfrac_period

    Number.sqrt_cfrac_period()

Return the

=cut

=head2 sqrt_cfrac_period_len

    n.sqrt_cfrac_period_len()

Return the length of the period of continued fraction for square root of n. (OEIS: A003285)

=cut

=head2 sqrtmod

    Number.sqrtmod()

Return the

=cut

=head2 square_divisors

    n.square_divisors()

Return the square divisors of n.

Example:

    say 5040.square_divisors    #=> [1, 4, 9, 16, 36, 144]

Equivalent with:

    n.divisors.grep { .is_square }

=cut

=head2 squarefree

squarefree(n)
squarefree(a,b)

Returns an array with the squarefree numbers <= n, or in the range a..b.

Example:

    # Squarefree numbers in the interval [100, 200]
    say squarefree(100, 200)

    # Squarefree numbers <= 100
    say squarefree(100)

=cut

=head2 squarefree_almost_primes

k.squarefree_almost_primes(n)
k.squarefree_almost_primes(a,b)

Returns an array with the squarefree k-almost primes <= n, or in the range a..b.

Example:

    say 2.squarefree_almost_primes(100)      #=> squarefree semiprimes <= 100
    say 2.squarefree_almost_primes(50, 100)  #=> squarefree semiprimes in the range 50..100

    say 3.squarefree_almost_primes(100)      #=> squarefree 3-almost primes <= 100
    say 3.squarefree_almost_primes(50, 100)  #=> squarefree 3-almost primes in the range 50..100

=cut

=head2 square_free_count

    Number.square_free_count()

Return the

Aliases: I<squarefree_count>

=cut

=head2 squarefree_divisors

    Number.squarefree_divisors()

Return the

=cut

=head2 squarefree_sigma

    Number.squarefree_sigma()

Return the

=cut

=head2 squarefree_sum

    n.squarefree_sum()

Returns the sum of squarefree numbers <= n. (OEIS: A066779)

Example:

    say squarefree_sum(1e12)    #=> 303963551353876732927386
    say squarefree_sum(1e13)    #=> 30396355090144154315002969

=cut

=head2 squarefree_udivisors

    Number.squarefree_udivisors()

Return the

Aliases: I<squarefree_unitary_divisors>, I<unitary_squarefree_divisors>

=cut

=head2 squarefree_usigma

    Number.squarefree_usigma()

Return the

=cut

=head2 squarefree_usigma0

    Number.squarefree_usigma0()

Return the

=cut

=head2 square_sigma

    Number.square_sigma()

Return the

=cut

=head2 square_sigma0

    Number.square_sigma0()

Return the

=cut

=head2 square_udivisors

    Number.square_udivisors()

Return the

Aliases: I<square_unitary_divisors>, I<unitary_square_divisors>

=cut

=head2 square_usigma

    Number.square_usigma()

Return the

=cut

=head2 square_usigma0

    Number.square_usigma0()

Return the

=cut

=head2 squfof_factor

    n.squfof_factor(reps)

Shanks' SQUFOF method.

=cut

=head2 stirling

    Number.stirling()

Return the

Aliases: I<stirling1>

=cut

=head2 stirling2

    Number.stirling2()

Return the

=cut

=head2 stirling3

    Number.stirling3()

Return the

=cut

=head2 subfactorial

    Number.subfactorial()

Return the

=cut

=head2 submod

    Number.submod()

Return the

=cut

=head2 subsets

    Number.subsets()

Return the

=cut

=head2 superfactorial

    Number.superfactorial()

Return the

=cut

=head2 superprimorial

    n.superprimorial()

Returns the product of first n primorials.

Example:

    say 10.of { .superprimorial }   #=> OEIS: A006939

=cut

=head2 tan

    Number.tan()

Return the

=cut

=head2 tangent_number

    Number.tangent_number()

Return the

=cut

=head2 tanh

    Number.tanh()

Return the

=cut

=head2 times

    Number.times()

Return the

=cut

=head2 to_f

    Number.to_f()

Return the

Aliases: I<float>, I<to_float>

=cut

=head2 to_n

    Number.to_n()

Return the

Aliases: I<to_num>

=cut

=head2 to_s

    Number.to_s()

Return the

Aliases: I<to_str>

=cut

=head2 totient

    Number.totient()

Return the

Aliases: I<euler_phi>, I<eulerphi>, I<euler_totient>

=cut

=head2 trial_factor

    n.trial_factor(limit)

Trial division.

=cut

=head2 tuples

    Number.tuples()

Return the

Aliases: I<variations>

=cut

=head2 tuples_with_repetition

    Number.tuples_with_repetition()

Return the

Aliases: I<variations_with_repetition>

=cut

=head2 udivisors

    Number.udivisors()

Return the

Aliases: I<unitary_divisors>

=cut

=head2 uphi

    n.uphi()

The unitary totient function. (OEIS: A047994)

=cut

=head2 usigma

    Number.usigma()

Return the

=cut

=head2 usigma0

    Number.usigma0()

Return the

Aliases: I<squarefree_sigma0>

=cut

=head2 valuation

    Number.valuation()

Return the

=cut

=head2 zero

    Number.zero()

Return the

=cut

=head2 znorder

    Number.znorder()

Return the

=cut

=head2 znprimroot

    Number.znprimroot()

Return the

=cut
