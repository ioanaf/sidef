#!/usr/bin/ruby

# Tests for some Number methods.

assert_eq(inverse_usigma(120), 1..120 -> grep { .usigma == 120 })
assert_eq(inverse_usigma(5040).len, 38)
assert_eq(inverse_usigma(5040).map { .usigma }.uniq, [5040])

assert_eq(inverse_sigma(120), 1..120 -> grep { .sigma == 120 })
assert_eq(inverse_sigma(240), 1..240 -> grep { .sigma == 240 })
assert_eq(inverse_sigma(5040).len, 33)
assert_eq(inverse_sigma(5040).map{.sigma}.uniq, [5040])

assert_eq(inverse_sigma(22100, 2), [120, 130, 141])

assert_eq(inverse_phi(120), [143, 155, 175, 183, 225, 231, 244, 248, 286, 308, 310, 350, 366, 372, 396, 450, 462])
assert_eq(inverse_phi(5040).len, 93)
assert_eq(inverse_phi(5040).map{ .phi }.uniq, [5040])

assert_eq(inverse_psi(240), 1..240 -> grep { .psi == 240 })
assert_eq(inverse_psi(5040).len, 38)
assert_eq(inverse_psi(5040).map{.psi}.uniq, [5040])

assert_eq(inverse_uphi(120), [121, 143, 144, 155, 164, 183, 220, 231, 240, 242, 286, 310, 366, 462])
assert_eq(inverse_uphi(5040).len, 90)
assert_eq(inverse_uphi(5040).map{.uphi}.uniq, [5040])

assert_eq(20.of { .omega },  20.of { .factor_exp.len })
assert_eq(20.of { .Omega },  20.of { .factor.len })

assert_eq(20.of { .tau },       20.of { .divisors.len })
assert_eq(20.of { .sigma },     20.of { .divisors.sum })
assert_eq(20.of { .sigma(2) },  20.of { .divisors.sum { _*_ } })

assert_eq(20.of { .phi },    20.of {|n| 1..n -> count_by { |k| is_coprime(n,k) } })
assert_eq(20.of { .usigma }, 20.of { _ ? .factor_map { |p,e| p**e + 1 }.prod : 0 })
assert_eq(20.of { .uphi },   20.of { _ ? .factor_map { |p,e| p**e - 1 }.prod : 0 })

assert_eq(1..100 -> grep { .is_smooth(5) }, 1..100 -> grep { .gpf <= 5 })
assert_eq(2..100 -> grep { .is_rough(5)  }, 2..100 -> grep { .lpf >= 5 })

assert_eq(50.of { .inverse_phi.len }, 50.of { .inverse_phi_len })
assert_eq(50.of { .inverse_psi.len }, 50.of { .inverse_psi_len })

assert_eq(50.of { .inverse_phi.max }, 50.of { .inverse_phi_max })
assert_eq(50.of { .inverse_psi.max }, 50.of { .inverse_psi_max })

assert_eq(50.of { .inverse_phi.min }, 50.of { .inverse_phi_min })
assert_eq(50.of { .inverse_psi.min }, 50.of { .inverse_psi_min })

assert_eq(50.of { .inverse_sigma.max }, 50.of { .inverse_sigma_max })
assert_eq(50.of { .inverse_sigma.min }, 50.of { .inverse_sigma_min })

assert_eq(50.of { .inverse_sigma.len }, 50.of { .inverse_sigma_len })
assert_eq(50.of { .inverse_sigma(2).len }, 50.of { .inverse_sigma_len(2) })

assert_eq(50.of { .inverse_sigma(2).max }, 50.of { .inverse_sigma_max(2) })
assert_eq(50.of { .inverse_sigma(2).min }, 50.of { .inverse_sigma_min(2) })

assert_eq(inverse_phi(2**64).len, inverse_phi_len(2**64))
assert_eq(inverse_psi(2**64).len, inverse_psi_len(2**64))
assert_eq(inverse_sigma(2**64).len, inverse_sigma_len(2**64))

assert_eq(inverse_phi(2**64).max, inverse_phi_max(2**64))
assert_eq(inverse_phi(2**64).min, inverse_phi_min(2**64))

assert_eq(inverse_psi(2**64).max, inverse_psi_max(2**64))
assert_eq(inverse_psi(2**64).min, inverse_psi_min(2**64))

assert_eq(inverse_sigma(2**64).max, inverse_sigma_max(2**64))
assert_eq(inverse_sigma(2**64).min, inverse_sigma_min(2**64))

assert_eq(50.of { .sigma(2) }.sort.uniq.grep { _ <= 50 }, 0..50 -> grep { defined(.inverse_sigma_min(2)) })
assert_eq(50.of { .sigma(2) }.sort.uniq.grep { _ <= 50 }, 0..50 -> grep { defined(.inverse_sigma_max(2)) })

do {
    var a = Math.smooth_numbers(2,3,5,7)    # 7-smooth numbers
    var b = Math.smooth_numbers(2,5,7)      # 7-smooth numbers not divisible by 3

    assert_eq(a.first(30), 30.by { .is_smooth(7) })
    assert_eq(b.first(30), 30.by {!.is_div(3) && .is_smooth(7) })

    # Iteration is also supported
    a.each {|k|
        if (k > 1e5) {
            assert_eq(k, 100352)
            break
        }
    }
}

for a,m in (
[
    [10, 13],
    [10, 13**2],
    [10, 13**3],
    [10, 13**4],
    [44, 43*97],
    [938, 1771],
    [1313, 3808],
    [544, 800],
    [436, 1752],
    [289, 992],
    [841, 905],
    [441, 920],
    [993, 2048],
    [13**18 * 5**7 - 1, 13**18 * 5**7]
]) {
    assert_eq(Mod(sqrtmod(a, m), m)**2, a, "sqrtmod(#{a}, #{m})")
}

assert_eq(squarefree_sum(1e6), 303961062910)
assert_eq(squarefree_sum(1e7), 30396557311887)

assert_eq(squarefree_count(1e9), 607927124)
assert_eq(squarefree_count(1e10), 6079270942)

for k in (0..10) {

    assert_eq(almost_primes(k, 1000), 1..1000 -> grep { .is_almost_prime(k) })
    assert_eq(gather { almost_primes_each(k, 1000, { take(_) }) }, almost_primes(k, 1000))

    var from = 1000.irand
    var upto = from+1000.irand

    assert_eq(almost_primes(k, from, upto), from..upto -> grep { .is_almost_prime(k) })
    assert_eq(gather { almost_primes_each(k, from, upto, { take(_) }) }, almost_primes(k, from, upto))
}

with (2**65) {|n|

    assert_eq(1.almost_primes(n, n+100), range(n, n+100).grep{.is_prime})
    assert_eq(gather { 1.almost_primes_each(n, n+100, { take(_) } ) }, range(n, n+100).grep{.is_almost_prime(1)})

    assert_eq(2.almost_primes(n, n+100), range(n, n+100).grep{.is_semiprime})
    assert_eq(gather { 2.almost_primes_each(n, n+100, { take(_) } ) }, range(n, n+100).grep{.is_almost_prime(2)})
}

for k in (1..12) {
    var n = k.pn_primorial

    #say "Testing: #{k} -> #{n}"

    var from = n-100
    var upto = n+100

    assert_eq(almost_primes(k, from, upto), from..upto -> grep{ .is_almost_prime(k) })
}

# RangeNumber k-almost primes

assert_eq(
    gather { 10..100 -> each_almost_prime(2, {|k| take(k) }) },
    2.almost_primes(10, 100)
)

assert_eq(
    gather { 10..100 -> each_almost_prime(3, {|k| take(k) }) },
    3.almost_primes(10, 100)
)

assert_eq(
    gather { 10..100 `by` 3 -> each_almost_prime(3, {|k| take(k) }) },
    10..100 `by` 3 -> grep { .is_almost_prime(3) }
)

assert_eq(
    gather { 10..100 `by` 3 -> each_almost_prime(2, {|k| take(k) }) },
    10..100 `by` 3 -> grep { .is_almost_prime(2) }
)

# RangeNumber k-powerful numbers

assert_eq(
    gather { 10..1000 -> each_powerful(2, {|k| take(k) }) },
    2.powerful(10, 1000)
)

assert_eq(
    gather { 10..1000 -> each_powerful(3, {|k| take(k) }) },
    3.powerful(10, 1000)
)

assert_eq(
    gather { 10..1000 `by` 3 -> each_powerful(3, {|k| take(k) }) },
    10..1000 `by` 3 -> grep { .is_powerful(3) }
)

assert_eq(
    gather { 10..1000 `by` 3 -> each_powerful(2, {|k| take(k) }) },
    10..1000 `by` 3 -> grep { .is_powerful(2) }
)

# RangeNumber squarefree numbers

assert_eq(
    gather { 10..100 -> each_squarefree {|k| take(k) } },
    squarefree(10, 100)
)

assert_eq(
    gather { 10..100 `by` 3 -> each_squarefree {|k| take(k) } },
    10..100 `by` 3 -> grep { .is_squarefree }
)

# RangeNumber prime numbers

assert_eq(
    gather { 10..100 -> each_prime {|k| take(k) } },
    primes(10, 100)
)

assert_eq(
    gather { 10..100 `by` 3 -> each_prime {|k| take(k) } },
    10..100 `by` 3 -> grep { .is_prime }
)

# RangeNumber semiprime numbers

assert_eq(
    gather { 10..100 -> each_semiprime {|k| take(k) } },
    semiprimes(10, 100)
)

assert_eq(
    gather { 10..100 `by` 3 -> each_semiprime {|k| take(k) } },
    10..100 `by` 3 -> grep { .is_semiprime }
)

say "** Tests passed!"
